[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Little Book of Python",
    "section": "",
    "text": "The Little Book of Python",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-1.-basics-of-python",
    "href": "index.html#chapter-1.-basics-of-python",
    "title": "The Little Book of Python",
    "section": "Chapter 1. Basics of Python",
    "text": "Chapter 1. Basics of Python\n\n1. What is Python?\nPython is a high-level, general-purpose programming language that emphasizes simplicity and readability. Created by Guido van Rossum in the early 1990s, Python was designed to make programming more accessible by using a clean, English-like syntax. Unlike lower-level languages such as C or assembly, Python abstracts away many technical details, allowing developers to focus on solving problems rather than managing memory or dealing with system-level operations.\nPython is both interpreted and dynamically typed. Being interpreted means that Python executes code line by line without requiring compilation into machine code beforehand. This makes it very beginner-friendly, as you can test and run your code quickly without extra steps. Being dynamically typed means you do not need to declare variable types explicitly—Python determines them at runtime, which speeds up development.\nThe language is also cross-platform. A Python program written on macOS can usually run on Linux or Windows with little to no changes, as long as the environment has Python installed. Combined with its vast ecosystem of libraries and frameworks, Python has become one of the most popular languages worldwide, used in areas ranging from web development to artificial intelligence.\nPython’s design philosophy emphasizes readability. For example, instead of curly braces ({}) to mark blocks of code, Python uses indentation (spaces or tabs). This enforces clean code structure and makes programs easier to read and maintain.\n\nDeep Dive\n\nVersatility: Python is sometimes called a “glue language” because it can integrate with other systems and languages easily. You can call C or C++ libraries, run shell commands, or embed Python into other applications.\nCommunity and ecosystem: With millions of developers worldwide, Python has a massive community. This means a wealth of tutorials, open-source projects, and support forums are available for learners and professionals.\nLibraries and frameworks: Python has specialized libraries for nearly every domain:\n\nData Science & AI: NumPy, Pandas, TensorFlow, PyTorch.\nWeb Development: Django, Flask, FastAPI.\nAutomation & Scripting: Selenium, BeautifulSoup, os and shutil modules.\nSystems Programming: subprocess, asyncio, threading tools.\n\nDesign Philosophy: The “Zen of Python” (accessible by running import this in a Python shell) summarizes guiding principles, such as “Simple is better than complex” and “Readability counts.”\n\nPython’s balance of simplicity and power makes it an excellent first language for beginners, yet powerful enough for advanced engineers building production-grade systems.\n\n\nTiny Code\n# A simple Python program\nprint(\"Hello, World!\")\n\n# Variables don't require type declarations\nx = 10       # integer\ny = 3.14     # float\nname = \"Ada\" # string\n\n# Control flow example\nif x &gt; 5:\n    print(f\"{name}, x is greater than 5!\")\n\n\nWhy it Matters\nPython matters because it lowers the barrier to entry into programming. Its readability and straightforward syntax make it an ideal starting point for newcomers, while its depth and ecosystem allow professionals to tackle complex problems in machine learning, finance, cybersecurity, and more. Learning Python often serves as a gateway to the broader world of computer science and software engineering.\n\n\nTry It Yourself\n\nOpen a terminal or Python shell and type print(\"Hello, Python!\").\nAssign a number to a variable and print it. Example:\nage = 25\nprint(\"I am\", age, \"years old.\")\nRun import this in the Python shell and read through the Zen of Python. Which line resonates with you most, and why?\n\nThis exercise introduces you to Python’s core design philosophy while letting you experience the simplicity of writing and running your first code.\n\n\n\n2. Installing Python & Running Scripts\nPython is available for almost every operating system, and installing it is the first step before you can write and execute your own programs. Most modern computers already come with Python preinstalled, but often it is not the latest version. For development, it is generally recommended to use the most recent stable release (for example, Python 3.12).\n\nDeep Dive\nDownload and Install:\n\nOn Windows, download the installer from the official website python.org. During installation, make sure to check the box “Add Python to PATH” so you can run Python from the command line.\nOn macOS, you can use Homebrew (brew install python) or download from python.org.\nOn Linux, Python is usually preinstalled. If not, use your package manager (sudo apt install python3 on Ubuntu/Debian, sudo dnf install python3 on Fedora).\n\nAfter installation, open your terminal (or command prompt) and type:\npython3 --version\nThis should display something like Python 3.14.0. If it doesn’t, the installation or PATH configuration may need adjustment.\nRunning the Interpreter (REPL):\nYou can enter interactive mode by typing python or python3 in your terminal. This launches the Read-Eval-Print Loop (REPL), where you can execute code line by line:\n&gt;&gt;&gt; 2 + 3\n5\n&gt;&gt;&gt; print(\"Hello, Python!\")\nHello, Python!\nRunning Scripts:\nWhile the REPL is good for quick experiments, most real programs are saved in files with a .py extension. You can create a file hello.py containing:\nprint(\"Hello from a script!\")\nThen run it from your terminal:\npython3 hello.py\nIDEs and Editors:\nBeginners often start with editors like IDLE (which comes with Python) or more advanced ones like VS Code or PyCharm, which provide syntax highlighting, debugging tools, and project management.\nEnvironment Management:\nInstalling libraries for one project can affect others. To avoid conflicts, Python provides virtual environments (venv). This isolates project dependencies:\npython3 -m venv myenv\nsource myenv/bin/activate   # On Linux/macOS\nmyenv\\Scripts\\activate      # On Windows\n\n\nTiny Code\n# File: hello.py\nname = \"Ada\"\nprint(\"Hello,\", name)\nTo run:\npython3 hello.py\n\n\nWhy it Matters\nUnderstanding how to install Python and run scripts is fundamental because it gives you control over your development environment. Without mastering this, you can’t progress to building real applications. Installing properly also ensures you have access to the latest features and security updates.\n\n\nTry It Yourself\n\nInstall the latest version of Python on your computer.\nVerify your installation with python3 --version.\nOpen the REPL and try basic arithmetic (5 * 7, 10 / 2).\nWrite a script called greeting.py that prints your name and favorite color.\nRun the script from your terminal.\n\nThis exercise ensures you can not only experiment interactively but also save and execute complete programs.\n\n\n\n3. Python Syntax & Indentation\nPython’s syntax is designed to be simple and human-readable. Unlike many other programming languages that use braces {} or keywords to define code blocks, Python uses indentation (spaces or tabs). This is not optional—correct indentation is part of Python’s grammar. The focus on clean and consistent code is one of the reasons why Python is popular both in education and professional development.\n\nDeep Dive\n\nIndentation Instead of Braces: In languages like C, C++, or Java, you often see:\nif (x &gt; 0) {\n    printf(\"Positive\\n\");\n}\nIn Python, the same block is defined by indentation:\nif x &gt; 0:\n    print(\"Positive\")\nThe colon (:) signals the start of a new block, and the indented lines that follow belong to that block.\nConsistency Matters: Python requires consistency in indentation. You cannot mix tabs and spaces within the same block. The most common convention is 4 spaces per indentation level.\nNested Indentation: Blocks can be nested by increasing indentation further:\nif x &gt; 0:\n    if x % 2 == 0:\n        print(\"Positive and even\")\n    else:\n        print(\"Positive and odd\")\nSyntax Simplicity: Python syntax avoids clutter. For example:\n\nNo need for semicolons (;) at the end of lines (though allowed).\nParentheses are optional in control statements unless needed for clarity.\nWhitespace and line breaks matter, which encourages writing readable code.\n\nLine Continuation: Long lines can be split with \\ or by wrapping expressions inside parentheses:\ntotal = (100 + 200 + 300 +\n         400 + 500)\nComments: Python uses # for single-line comments and triple quotes (\"\"\" ... \"\"\") for docstrings or multi-line comments.\n\n\n\nTiny Code\n# Proper indentation example\nscore = 85\n\nif score &gt;= 60:\n    print(\"Pass\")\n    if score &gt;= 90:\n        print(\"Excellent\")\n    else:\n        print(\"Good job\")\nelse:\n    print(\"Fail\")\n\n\nWhy it Matters\nIndentation rules enforce consistency across all Python code. This reduces errors caused by messy formatting and makes programs easier to read, especially when working in teams. Python’s syntax philosophy ensures beginners learn clean habits from the start and professionals maintain readability in large projects.\n\n\nTry It Yourself\n\nWrite a program that checks if a number is positive, negative, or zero using proper indentation.\nExperiment by removing indentation or mixing spaces and tabs—notice how Python raises an IndentationError.\nWrite nested if statements to check whether a number is divisible by both 2 and 3.\n\nThis will help you experience firsthand why Python enforces indentation and how it guides you to write clean, structured code.\n\n\n\n4. Variables & Assignment\nIn Python, a variable is like a box with a name where you can store information. You can put numbers, text, or other kinds of data inside that box, and later use the name of the box to get the value back.\nUnlike some languages, you don’t need to say what kind of data will go inside the box—Python figures it out for you automatically.\n\nDeep Dive\n\nCreating a Variable: You just choose a name and use the equals sign = to assign a value:\nage = 20\nname = \"Alice\"\nheight = 1.75\nReassigning a Variable: You can change the value at any time:\nage = 21   # overwrites the old value\nNaming Rules:\n\nNames can include letters, numbers, and underscores (_).\nThey cannot start with a number.\nThey are case-sensitive: Age and age are different.\nUse meaningful names, like temperature, instead of t.\n\nDynamic Typing: Python does not require you to declare the type. The same variable can hold different types of data at different times:\nx = 10      # integer\nx = \"hello\" # now it's a string\nMultiple Assignments: You can assign several variables in one line:\na, b, c = 1, 2, 3\nSwapping Values: Python makes it easy to swap values without a temporary variable:\na, b = b, a\n\n\n\nTiny Code\n# Assign variables\nname = \"Ada\"\nage = 25\n\n# Print them\nprint(\"My name is\", name)\nprint(\"I am\", age, \"years old\")\n\n\nWhy it Matters\nVariables let you store and reuse information in your programs. Without variables, you would have to repeat values everywhere, making your code harder to read and change. They are the foundation of all programming.\n\n\nTry It Yourself\n\nCreate a variable called color and assign your favorite color as text.\nMake a variable number and assign it any number you like.\nPrint both values in a sentence, like:\nMy favorite color is blue and my number is 7\nTry changing the values and run the program again.\n\nThis will show you how variables make your code flexible and easy to update.\n\n\n\n4. Variables & Assignment\nIn Python, a variable is like a box with a name where you can store information. You can put numbers, text, or other kinds of data inside that box, and later use the name of the box to get the value back.\nUnlike some languages, you don’t need to say what kind of data will go inside the box—Python figures it out for you automatically.\n\nDeep Dive\nTo create a variable, you simply choose a name and use the equals sign = to assign a value. For example:\nage = 20\nname = \"Alice\"\nheight = 1.75\nYou can also change the value at any time. For instance:\nage = 21   # overwrites the old value\nVariable names have a few rules. They can include letters, numbers, and underscores (_), but they cannot start with a number. They are also case-sensitive, so Age and age are considered different. It’s a good habit to use meaningful names, like temperature instead of just t.\nPython uses dynamic typing, which means you don’t have to declare the type of data in advance. A single variable can hold different types of data at different times:\nx = 10      # integer\nx = \"hello\" # now it's a string\nYou can even assign several variables in one line, like this:\na, b, c = 1, 2, 3\nAnd if you ever need to swap the values of two variables, Python makes it very easy without needing a temporary helper:\na, b = b, a\n\n\nTiny Code\n# Assign variables\nname = \"Ada\"\nage = 25\n\n# Print them\nprint(\"My name is\", name)\nprint(\"I am\", age, \"years old\")\n\n\nWhy it Matters\nVariables let you store and reuse information in your programs. Without variables, you would have to repeat values everywhere, making your code harder to read and change. They are the foundation of all programming.\n\n\nTry It Yourself\n\nCreate a variable called color and assign your favorite color as text.\nMake a variable number and assign it any number you like.\nPrint both values in a sentence, like:\nMy favorite color is blue and my number is 7\nTry changing the values and run the program again.\n\nThis will show you how variables make your code flexible and easy to update.\n\n\n\n5. Data Types Overview\nEvery piece of information in Python has a data type. A data type tells Python what kind of thing the value is—whether it’s a number, text, a list of items, or something else. Understanding data types is important because it helps you know what you can and cannot do with a value.\n\nDeep Dive\nPython has several basic data types you’ll use all the time.\nNumbers are used for math. Python has three main kinds of numbers: integers (int) for whole numbers, floating-point numbers (float) for decimals, and complex numbers (complex) which are used less often, mostly in math and engineering.\nStrings (str) represent text. Anything inside quotes, either single ('hello') or double (\"hello\"), is treated as a string. Strings can hold words, sentences, or even whole paragraphs.\nBooleans (bool) represent truth values—either True or False. These are useful for decision making in programs, like checking if a condition is met.\nCollections let you store multiple values in a single variable. Lists (list) are ordered, changeable collections of items, like [1, 2, 3]. Tuples (tuple) are like lists but cannot be changed after creation, such as (1, 2, 3). Sets (set) are collections of unique, unordered items. Dictionaries (dict) store data as key–value pairs, like {\"name\": \"Alice\", \"age\": 25}.\nThere are also special types like NoneType, which only has the value None. This represents “nothing” or “no value.”\nPython figures out the type of a variable automatically. If you want to check a variable’s type, you can use the built-in type() function:\nx = 42\nprint(type(x))  # &lt;class 'int'&gt;\n\n\nTiny Code\n# Examples of different data types\nnumber = 10          # int\npi = 3.14            # float\nname = \"Ada\"         # str\nis_student = True    # bool\nitems = [1, 2, 3]    # list\npoint = (2, 3)       # tuple\nunique = {1, 2, 3}   # set\nperson = {\"name\": \"Ada\", \"age\": 25}  # dict\nnothing = None       # NoneType\n\nprint(type(name))    # check type\n\n\nWhy it Matters\nData types are the foundation of programming logic. Knowing the type of data tells you what operations you can perform. For example, you can add two numbers but not a number and a string without converting one of them. This prevents errors and helps you design programs correctly.\n\n\nTry It Yourself\n\nCreate a variable city with the name of your city.\nMake a list called colors with three of your favorite colors.\nCreate a dictionary book with keys title and author.\nPrint out the type of each variable using type().\nTry combining different types (like adding a string and a number) and see what error appears.\n\nThis will give you a feel for how Python handles different data and why types matter.\n\n\n\n6. Numbers (int, float, complex)\nNumbers are one of the most basic building blocks in Python. They allow you to do math, represent quantities, and calculate results in your programs. Python has three main types of numbers: integers (int), floating-point numbers (float), and complex numbers (complex).\n\nDeep Dive\nNumber Types in Python\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n-3, 0, 42\nWhole numbers, no decimal part. Can be very large (only limited by memory).\n\n\nfloat\n3.14, -0.5\nNumbers with decimal points, often used for measurements or precision math.\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts, useful in math, physics, engineering.\n\n\n\nCommon Arithmetic Operators\n\n\n\n\n\n\n\n\n\nOperator\nExample\nResult\nMeaning\n\n\n\n\n+\n5 + 2\n7\nAddition\n\n\n-\n5 - 2\n3\nSubtraction\n\n\n*\n5 * 2\n10\nMultiplication\n\n\n/\n5 / 2\n2.5\nDivision (always float)\n\n\n//\n5 // 2\n2\nFloor division (whole number part only)\n\n\n%\n5 % 2\n1\nModulo (remainder)\n\n\n`|2 3|8`\nExponent (raise to a power)\n\n\n\n\n\nType Conversion\n\n\n\nFunction\nExample\nResult\n\n\n\n\nint()\nint(3.9)\n3\n\n\nfloat()\nfloat(7)\n7.0\n\n\ncomplex()\ncomplex(2, 3)\n2+3j\n\n\n\nYou can check the type of any number with the type() function:\nx = 42\nprint(type(x))  # &lt;class 'int'&gt;\n\n\nTiny Code\n# Integers\na = 10\nb = -3\n\n# Floats\npi = 3.14\ng = 9.81\n\n# Complex\nz = 2 + 3j\n\n# Operations\nprint(a + b)    # 7\nprint(a / 2)    # 5.0\nprint(a // 2)   # 5\nprint(a % 3)    # 1\nprint(2  3)   # 8\n\n# Type checking\nprint(type(pi)) # &lt;class 'float'&gt;\nprint(type(z))  # &lt;class 'complex'&gt;\n\n\nWhy it Matters\nNumbers are essential for everything from simple calculations to complex algorithms. Understanding the different numeric types and how they behave allows you to choose the right one for each situation. Use integers for counting, floats for precise measurements, and complex numbers for specialized scientific work.\n\n\nTry It Yourself\n\nCreate two integers and try all the arithmetic operators (+, -, *, /, //, %, ``).\nMake a float variable for your height (like 1.75) and multiply it by 2.\nExperiment with int(), float(), and complex() to convert between number types.\nWrite a complex number and print both its real and imaginary parts using .real and .imag.\n\nThis will help you see how Python handles different numeric types in practice.\n\n\n\n7. Strings (creation & basics)\nA string in Python is a sequence of characters—letters, numbers, symbols, or even spaces—enclosed in quotes. Strings are used whenever you want to work with text, such as names, sentences, or file paths.\n\nDeep Dive\nCreating Strings\nYou can create strings using either single quotes or double quotes:\nname = 'Alice'\ngreeting = \"Hello, world!\"\nFor multi-line text, you can use triple quotes:\nparagraph = \"\"\"This is a \nmulti-line string.\"\"\"\nBasic String Operations\n\n\n\nOperation\nExample\nResult\n\n\n\n\nConcatenation\n\"Hello\" + \" \" + \"Bob\"\n\"Hello Bob\"\n\n\nRepetition\n\"ha\" * 3\n\"hahaha\"\n\n\nIndexing\n\"Python\"[0]\n'P'\n\n\nNegative Indexing\n\"Python\"[-1]\n'n'\n\n\nSlicing\n\"Python\"[0:4]\n\"Pyth\"\n\n\nLength\nlen(\"Python\")\n6\n\n\n\nEscape Characters\nSometimes you need special characters inside a string:\n\n\n\n\n\n\n\n\n\nEscape Code\nMeaning\nExample\nResult\n\n\n\n\n\\n\nNew line\n\"Hello\\nWorld\"\nHelloWorld\n\n\n\\t\nTab\n\"A\\tB\"\nA    B\n\n\n\\'\nSingle quote\n'It\\'s fine'\nIt's fine\n\n\n\\\"\nDouble quote\n\"He said \\\"Hi\\\"\"\nHe said \"Hi\"\n\n\n\\\\\nBackslash\n\"C:\\\\Users\\\\Alice\"\nC:\\Users\\Alice\n\n\n\n\n\nTiny Code\n# Creating strings\nword = \"Python\"\nsentence = 'I love coding'\nmultiline = \"\"\"This is\na string that spans\nmultiple lines.\"\"\"\n\n# Operations\nprint(word[0])        # 'P'\nprint(word[-1])       # 'n'\nprint(word[0:3])      # 'Pyt'\nprint(word + \" 3.12\") # 'Python 3.12'\nprint(\"ha\" * 4)       # 'hahaha'\n\n# Escape characters\npath = \"C:\\\\Users\\\\Alice\"\nprint(path)\n\n\nWhy it Matters\nStrings are everywhere—whether you’re printing messages, reading files, sending data across the internet, or handling user input. Mastering how to create and manipulate strings is essential for building real-world Python programs.\n\n\nTry It Yourself\n\nCreate a string with your full name and print the first letter and the last letter.\nWrite a sentence and use slicing to print only the first 5 characters.\nUse string concatenation to join \"Hello\" and your name with a space in between.\nMake a string with an escape sequence, like \"Line1\\nLine2\", and print it.\n\nThis practice will help you understand how Python treats text as data you can store, manipulate, and display.\n\n\n\n8. Booleans and Truth Values\nBooleans are the simplest type of data in Python. They represent only two values: True or False. Booleans are often the result of comparisons or conditions in a program, and they control the flow of logic, such as deciding which branch of an if statement should run.\n\nDeep Dive\nBoolean Values\nIn Python, the boolean type is bool. There are only two possible values:\nis_sunny = True\nis_raining = False\nNotice that True and False are capitalized—writing true or false will cause an error.\nComparisons That Produce Booleans\n\n\n\nExpression\nExample\nResult\n\n\n\n\nEqual\n5 == 5\nTrue\n\n\nNot equal\n5 != 3\nTrue\n\n\nGreater than\n7 &gt; 10\nFalse\n\n\nLess than\n2 &lt; 5\nTrue\n\n\nGreater/Equal\n3 &gt;= 3\nTrue\n\n\nLess/Equal\n4 &lt;= 2\nFalse\n\n\n\nBoolean Logic\nPython also supports logical operators that combine boolean values:\n\n\n\nOperator\nExample\nResult\n\n\n\n\nand\nTrue and False\nFalse\n\n\nor\nTrue or False\nTrue\n\n\nnot\nnot True\nFalse\n\n\n\nTruthiness in Python\nNot just True and False are considered booleans. Many values in Python have an implicit boolean value:\n\n\n\nValue Type\nConsidered as\n\n\n\n\n0, 0.0, 0j\nFalse\n\n\nEmpty string \"\"\nFalse\n\n\nEmpty list []\nFalse\n\n\nEmpty dict {}\nFalse\n\n\nNone\nFalse\n\n\nEverything else\nTrue\n\n\n\nYou can test this with the bool() function:\nprint(bool(0))     # False\nprint(bool(\"hi\"))  # True\n\n\nTiny Code\nx = 10\ny = 20\n\nprint(x &lt; y)          # True\nprint(x == y)         # False\nprint((x &lt; y) and (y &gt; 5))  # True\nprint(not (x &gt; y))    # True\n\n# Truthiness\nprint(bool(\"\"))       # False\nprint(bool(\"Python\")) # True\n\n\nWhy it Matters\nBooleans are the foundation of decision-making in programming. They let you write programs that can react differently depending on conditions—like checking if a user is logged in, if there is enough money in a bank account, or if a file exists. Without booleans, all programs would just run straight through without making choices.\n\n\nTry It Yourself\n\nAssign a boolean variable is_python_fun = True and print it.\nCompare two numbers (like 5 &gt; 3) and store the result in a variable. Print the variable.\nTest the truthiness of an empty list [] and a non-empty list [1, 2, 3] with bool().\nWrite an expression using and, or, and not together.\n\nThis practice will help you see how conditions and logic form the backbone of Python programs.\n\n\n\n9. Comments in Python\nComments are notes you add to your code that Python ignores when running the program. They’re meant for humans, not the computer. Comments explain what your code does, why you wrote it a certain way, or leave reminders for yourself and others.\n\nDeep Dive\nSingle-Line Comments In Python, the # symbol marks the start of a comment. Everything after it on the same line is ignored by Python:\n# This is a single-line comment\nx = 10  # You can also put a comment after code\nMulti-Line Comments (Docstrings) Python doesn’t have a special syntax just for multi-line comments, but programmers often use triple quotes (\"\"\" or '''). These are usually used for docstrings (documentation strings), but they can serve as block comments if not assigned to a variable:\n\"\"\"\nThis is a multi-line comment.\nYou can use triple quotes\nto write long explanations.\n\"\"\"\nDocstrings for Functions and Classes Triple quotes are more commonly used as docstrings to document functions, classes, or modules. They are placed right after the definition line:\ndef greet(name):\n    \"\"\"\n    This function takes a name\n    and prints a greeting.\n    \"\"\"\n    print(\"Hello,\", name)\nYou can read docstrings later using the help() function.\nWhy Comments Are Useful\n\n\n\n\n\n\n\nPurpose\nExample\n\n\n\n\nExplain code logic\n# Loop through items in the list\n\n\nClarify tricky parts\n# Using floor division to ignore decimals\n\n\nLeave reminders (TODOs, FIXMEs)\n# TODO: handle negative numbers\n\n\nProvide documentation\nDocstrings that explain functions, classes, or entire files\n\n\n\nGood comments don’t just repeat the code; they explain the why, not just the what.\n\n\nTiny Code\n# Store a user's age\nage = 25\n\n# Check if age is greater than 18\nif age &gt; 18:\n    print(\"Adult\")\n\ndef square(x):\n    \"\"\"Return the square of a number.\"\"\"\n    return x * x\n\nprint(square(4))  # prints 16\n\n\nWhy it Matters\nComments make your code easier to understand for both yourself and others. Six months from now, you might forget why you wrote something. Clear comments act like a guidebook. In teams, comments and docstrings are essential for collaboration, as they make the codebase easier to maintain.\n\n\nTry It Yourself\n\nWrite a small program that calculates the area of a rectangle. Add comments explaining what each step does.\nUse a triple-quoted docstring to describe what the whole program does at the top of your file.\nAdd a TODO comment to remind yourself to improve the program later (for example, adding user input).\n\nThis will show you how comments make programs not just for computers, but for people too.\n\n\n\n10. Printing Output (print function)\nThe print() function is one of the most commonly used tools in Python. It lets you display information on the screen so you can see the result of your program, check values, or interact with users.\n\nDeep Dive\nBasic Printing The simplest use of print() is to show text:\nprint(\"Hello, world!\")\nPrinting Variables You can print variables directly by passing them to print():\nname = \"Ada\"\nage = 25\nprint(name)\nprint(age)\nPrinting Multiple Values print() can take multiple arguments separated by commas. Python will add spaces between them automatically:\nprint(\"Name:\", name, \"Age:\", age)\nString Formatting There are several ways to make your output more readable:\n\n\n\n\n\n\n\n\nMethod\nExample\nOutput\n\n\n\n\nf-strings (modern)\nprint(f\"{name} is {age} years old\")\nAda is 25 years old\n\n\n.format() method\nprint(\"{} is {}\".format(name, age))\nAda is 25\n\n\nOld % style\nprint(\"%s is %d\" % (name, age))\nAda is 25\n\n\n\nEnd and Separator Options By default, print() ends with a new line (\\n). You can change this using the end parameter:\nprint(\"Hello\", end=\" \")\nprint(\"World\")\n# Output: Hello World\nYou can also change the separator between multiple items using sep:\nprint(\"apple\", \"banana\", \"cherry\", sep=\", \")\n# Output: apple, banana, cherry\nPrinting Special Characters You can print new lines or tabs with escape sequences:\nprint(\"Line1\\nLine2\")\nprint(\"A\\tB\")\n\n\nTiny Code\nname = \"Grace\"\nlanguage = \"Python\"\nyear = 1991\n\nprint(\"Hello, world!\")\nprint(\"My name is\", name)\nprint(f\"{name} created {language} in {year}?\")\nprint(\"apple\", \"orange\", \"grape\", sep=\" | \")\n\n\nWhy it Matters\nPrinting is the most direct way to see what your program is doing. It helps you understand results, debug mistakes, and communicate with users. Even professional developers rely heavily on print() when testing and exploring code quickly.\n\n\nTry It Yourself\n\nPrint your name and your favorite hobby in one sentence.\nCreate two numbers and print their sum with a clear message.\nUse sep to print three words separated by dashes (-).\nUse end to print two words on the same line without spaces.\n\nThis will show you how flexible print() is for displaying information in Python.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-2.-control-flow",
    "href": "index.html#chapter-2.-control-flow",
    "title": "The Little Book of Python",
    "section": "Chapter 2. Control Flow",
    "text": "Chapter 2. Control Flow\n\n11. Comparison Operators\nComparison operators let you compare two values and return a boolean result (True or False). They are the foundation for making decisions in Python programs—without them, you couldn’t check conditions like “Is this number bigger than that number?” or “Are these two things equal?”\n\nDeep Dive\nComparison operators work on numbers, strings, and many other types. They allow you to check equality, inequality, and order.\nBasic Comparison Operators\n\n\n\nOperator\nExample\nMeaning\nResult\n\n\n\n\n==\n5 == 5\nEqual to\nTrue\n\n\n!=\n5 != 3\nNot equal to\nTrue\n\n\n&gt;\n7 &gt; 3\nGreater than\nTrue\n\n\n&lt;\n2 &lt; 5\nLess than\nTrue\n\n\n&gt;=\n3 &gt;= 3\nGreater than or equal to\nTrue\n\n\n&lt;=\n4 &lt;= 2\nLess than or equal to\nFalse\n\n\n\nComparisons always return True or False, which can be stored in variables or used directly inside control flow statements (if, while).\nChained Comparisons Python allows chaining comparisons for readability:\nx = 5\nprint(1 &lt; x &lt; 10)  # True\nprint(10 &lt; x &lt; 20) # False\nThis is equivalent to writing (1 &lt; x) and (x &lt; 10).\nComparisons with Strings Strings are compared alphabetically (lexicographically), based on Unicode values:\nprint(\"apple\" == \"apple\")  # True\nprint(\"apple\" &lt; \"banana\")  # True\nprint(\"Zebra\" &lt; \"apple\")   # True (uppercase letters come first)\n\n\nTiny Code\nx = 10\ny = 20\n\nprint(x == y)   # False\nprint(x != y)   # True\nprint(x &gt; y)    # False\nprint(x &lt;= y)   # True\n\n# Chain comparisons\nprint(5 &lt; x &lt; 15)  # True\n\n\nWhy it Matters\nWithout comparisons, programs couldn’t make choices. They are the basis for decisions like checking passwords, validating input, controlling loops, or comparing values in data. Every real-world Python program relies on comparison operators to “decide what to do next.”\n\n\nTry It Yourself\n\nWrite a program that compares two numbers (a = 7, b = 12) and prints whether a is less than, greater than, or equal to b.\nCreate two strings and check if they are equal.\nUse a chained comparison to check if a number n = 15 is between 10 and 20.\nExperiment with &lt; and &gt; on strings like \"cat\" and \"dog\" to see how Python compares text.\n\n\n\n\n12. Logical Operators\nLogical operators combine boolean values (True or False) to form more complex conditions. They are essential when you want to check multiple things at once, like “Is the number positive and even?” or “Is this user an admin or a guest?”\n\nDeep Dive\nPython has three main logical operators:\n\n\n\n\n\n\n\n\n\nOperator\nExample\nResult\nMeaning\n\n\n\n\nand\nTrue and False\nFalse\nTrue only if both sides are True\n\n\nor\nTrue or False\nTrue\nTrue if at least one side is True\n\n\nnot\nnot True\nFalse\nFlips the truth value (True → False)\n\n\n\nTruth Tables\nand operator:\n\n\n\nA\nB\nA and B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\nor operator:\n\n\n\nA\nB\nA or B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\nnot operator:\n\n\n\nA\nnot A\n\n\n\n\nTrue\nFalse\n\n\nFalse\nTrue\n\n\n\nCombining Conditions Logical operators are often used in if statements:\nage = 20\nis_student = True\n\nif age &gt; 18 and is_student:\n    print(\"Eligible for student discount\")\nShort-Circuiting Python stops evaluating as soon as the result is known:\n\nFor and, if the first condition is False, Python won’t check the second.\nFor or, if the first condition is True, Python won’t check the second.\n\n\n\nTiny Code\nx = 10\ny = 5\n\nprint(x &gt; 0 and y &gt; 0)   # True\nprint(x &gt; 0 or y &lt; 0)    # True\nprint(not (x == y))      # True\n\n# Short-circuit example\nprint(False and (10/0))  # False, no error (second part skipped)\nprint(True or (10/0))    # True, no error (second part skipped)\n\n\nWhy it Matters\nLogical operators allow your programs to make more complex decisions by combining multiple conditions. They’re at the heart of all real-world logic, from validating form inputs to controlling access in applications.\n\n\nTry It Yourself\n\nWrite a condition that checks if a number is both positive and less than 100.\nCheck if a variable name is either \"Alice\" or \"Bob\".\nUse not to test if a list is empty (not my_list).\nExperiment with short-circuiting by combining and or or with expressions that would normally cause an error.\n\n\n\n\n13. if Statements\nAn if statement lets your program make decisions. It checks a condition, and if that condition is True, it runs a block of code. If the condition is False, the block is skipped. This is the most basic form of control flow in Python.\n\nDeep Dive\nBasic Structure\nif condition:\n    # code runs only if condition is True\nThe colon (:) signals the start of the block, and indentation shows which lines belong to the if.\nExample\nx = 10\nif x &gt; 5:\n    print(\"x is greater than 5\")\nSince x &gt; 5 is True, the message is printed.\nCondition Can Be Any Boolean Expression The expression inside if must evaluate to True or False. This can come from comparisons, logical operators, or truthy/falsy values:\nif \"hello\":     # non-empty string is True\n    print(\"This runs\")\nIndentation is Required All code inside the if block must be indented the same amount. Without correct indentation, Python will raise an IndentationError.\n\n\nTiny Code\ntemperature = 30\n\nif temperature &gt; 25:\n    print(\"It's a hot day!\")\n\nif temperature &lt; 0:\n    print(\"It's freezing!\")\n\n\nWhy it Matters\nWithout if statements, programs would always run the same way. Conditions make programs dynamic and responsive—whether it’s checking user input, validating data, or making choices in games, if is the starting point for logic in Python.\n\n\nTry It Yourself\n\nWrite an if statement that prints \"Positive\" if a number is greater than zero.\nTest what happens if the number is zero—does the code run or not?\nUse an if statement to check if a string is empty, and print \"Empty string\" when it is.\nChange the indentation in your code incorrectly and observe Python’s error message.\n\n\n\n\n14. if...else\nThe if...else structure lets your program choose between two paths. If the condition is True, the if block runs. If the condition is False, the else block runs instead. This ensures that one of the two blocks always executes.\n\nDeep Dive\nBasic Structure\nif condition:\n    # code runs if condition is True\nelse:\n    # code runs if condition is False\nExample\nage = 16\n\nif age &gt;= 18:\n    print(\"You can vote\")\nelse:\n    print(\"You are too young to vote\")\nHere, if age is 18 or more, the first message is printed. Otherwise, the second one runs.\nif...else with Variables You can use the result of conditions to assign values:\nx = 10\ny = 20\n\nbigger = x if x &gt; y else y\nprint(bigger)   # 20\nThis is called a ternary expression (or conditional expression).\nOnly One else An if statement can have at most one else, and it always comes last.\n\n\nTiny Code\nscore = 75\n\nif score &gt;= 60:\n    print(\"Pass\")\nelse:\n    print(\"Fail\")\n\n\nWhy it Matters\nThe if...else structure makes programs capable of handling two outcomes: one when a condition is met, and another when it isn’t. It’s essential for branching logic—without it, you could only run code when conditions are true, not handle the “otherwise” case.\n\n\nTry It Yourself\n\nWrite a program that checks if a number is even or odd using if...else.\nCreate a variable temperature and print \"Warm\" if it’s 20 or above, otherwise \"Cold\".\nUse a conditional expression to set status = \"adult\" if age &gt;= 18, else \"minor\".\nChange the condition to test different inputs and see how the output changes.\n\n\n\n\n15. if...elif...else\nThe if...elif...else structure lets you check multiple conditions in order. The program will run the first block where the condition is True, and then skip the rest. If none of the conditions are true, the else block runs.\n\nDeep Dive\nBasic Structure\nif condition1:\n    # runs if condition1 is True\nelif condition2:\n    # runs if condition1 is False AND condition2 is True\nelif condition3:\n    # runs if above are False AND condition3 is True\nelse:\n    # runs if none of the above are True\nExample\nscore = 85\n\nif score &gt;= 90:\n    print(\"Excellent\")\nelif score &gt;= 75:\n    print(\"Good\")\nelif score &gt;= 60:\n    print(\"Pass\")\nelse:\n    print(\"Fail\")\nHere, Python checks each condition in order. Since score &gt;= 75 is true, it prints \"Good\" and skips the rest.\nOrder Matters Conditions are checked from top to bottom. As soon as one is True, Python stops checking further. For example:\nx = 100\nif x &gt; 50:\n    print(\"Bigger than 50\")\nelif x &gt; 10:\n    print(\"Bigger than 10\")\nOnly \"Bigger than 50\" is printed, even though x &gt; 10 is also true.\nOptional Parts\n\nThe elif can appear as many times as needed.\nThe else is optional—you don’t need it if you only want to handle some cases.\n\n\n\nTiny Code\nday = \"Wednesday\"\n\nif day == \"Monday\":\n    print(\"Start of the week\")\nelif day == \"Friday\":\n    print(\"Almost weekend\")\nelif day == \"Saturday\" or day == \"Sunday\":\n    print(\"Weekend!\")\nelse:\n    print(\"Midweek day\")\n\n\nWhy it Matters\nMost real-life decisions aren’t just yes-or-no. The if...elif...else chain lets you handle multiple possibilities in an organized way, making your code more flexible and readable.\n\n\nTry It Yourself\n\nWrite a program that checks a number and prints \"Positive\", \"Negative\", or \"Zero\".\nCreate a grading system: 90+ = A, 75–89 = B, 60–74 = C, below 60 = F.\nWrite code that prints which day of the week it is, based on a variable day.\nExperiment by changing the order of conditions and observe how the output changes.\n\n\n\n\n16. Nested Conditions\nA nested condition means putting one if statement inside another. This allows your program to make more specific decisions by checking an additional condition only when the first one is true.\n\nDeep Dive\nBasic Structure\nif condition1:\n    if condition2:\n        # runs if both condition1 and condition2 are True\n    else:\n        # runs if condition1 is True but condition2 is False\nelse:\n    # runs if condition1 is False\nExample\nage = 20\nis_student = True\n\nif age &gt;= 18:\n    if is_student:\n        print(\"Adult student\")\n    else:\n        print(\"Adult, not a student\")\nelse:\n    print(\"Minor\")\nHere, the second check (is_student) only happens if the first check (age &gt;= 18) is true.\nWhy Nesting is Useful Nested conditions let you handle cases that depend on multiple layers of logic. However, too much nesting can make code hard to read. In such cases, logical operators (and, or) are often better:\nif age &gt;= 18 and is_student:\n    print(\"Adult student\")\nBest Practice\n\nUse nesting when the second condition should only be checked if the first one is true.\nFor readability, avoid deep nesting—prefer combining conditions with logical operators when possible.\n\n\n\nTiny Code\nx = 15\n\nif x &gt; 0:\n    if x % 2 == 0:\n        print(\"Positive even number\")\n    else:\n        print(\"Positive odd number\")\nelse:\n    print(\"Zero or negative number\")\n\n\nWhy it Matters\nNested conditions add depth to decision-making. They let you structure logic in layers, which is closer to how we reason in real life—for example, “If the shop is open, then check if I have enough money.”\n\n\nTry It Yourself\n\nWrite a program that checks if a number is positive. If it is, then check if it’s greater than 100.\nMake a program that checks if someone is eligible to drive: first check if age &gt;= 18, then check if has_license == True.\nRewrite one of your nested conditions using and instead, and compare which version is easier to read.\n\n\n\n\n17. while Loop\nA while loop lets your program repeat a block of code as long as a condition is True. It’s useful when you don’t know in advance how many times you need to loop—for example, waiting for user input or running until some condition changes.\n\nDeep Dive\nBasic Structure\nwhile condition:\n    # code runs as long as condition is True\nExample\ncount = 1\nwhile count &lt;= 5:\n    print(\"Count is:\", count)\n    count += 1\nThis loop prints numbers from 1 to 5. Each time, count increases by 1 until the condition count &lt;= 5 is no longer true.\nInfinite Loops If the condition never becomes False, the loop will run forever. For example:\nwhile True:\n    print(\"This never ends!\")\nYou must stop such loops manually (Ctrl+C in most terminals).\nUsing break to Stop Early You can break out of a while loop when needed:\nx = 0\nwhile x &lt; 10:\n    if x == 5:\n        break\n    print(x)\n    x += 1\nUsing continue to Skip The continue keyword skips to the next iteration without finishing the rest of the loop body.\nCommon Use Cases\n\nWaiting for user input until valid\nRepeating a task until a condition is met\nInfinite background tasks with break conditions\n\n\n\nTiny Code\n# Print even numbers less than 10\nnum = 0\nwhile num &lt; 10:\n    num += 1\n    if num % 2 == 1:\n        continue\n    print(num)\n\n\nWhy it Matters\nThe while loop gives your program flexibility to keep running until something changes. It’s a powerful way to model “keep doing this until…” logic that often appears in real-world problems.\n\n\nTry It Yourself\n\nWrite a loop that counts down from 10 to 1.\nCreate a loop that keeps asking the user for a password until the correct one is entered.\nUse while True with a break to simulate a simple menu system (e.g., type q to quit).\nExperiment with continue to skip printing odd numbers.\n\n\n\n\n18. for Loop (range)\nA for loop in Python is used to repeat a block of code a specific number of times. Unlike the while loop, which runs as long as a condition is true, the for loop usually goes through a sequence of values—often created with the built-in range() function.\n\nDeep Dive\nBasic Structure\nfor variable in sequence:\n    # code runs for each item in the sequence\nUsing range() The range() function generates a sequence of numbers.\n\nrange(stop) → numbers from 0 up to stop - 1\nrange(start, stop) → numbers from start up to stop - 1\nrange(start, stop, step) → numbers from start up to stop - 1, moving by step\n\nExamples:\nfor i in range(5):\n    print(i)       # 0, 1, 2, 3, 4\n\nfor i in range(2, 6):\n    print(i)       # 2, 3, 4, 5\n\nfor i in range(0, 10, 2):\n    print(i)       # 0, 2, 4, 6, 8\nLooping with else A for loop can have an optional else block that runs if the loop finishes normally (not stopped by break).\nfor i in range(3):\n    print(i)\nelse:\n    print(\"Loop finished\")\nCommon Patterns\n\nCounting a fixed number of times\nIterating over list indexes\nGenerating sequences for calculations\n\n\n\nTiny Code\n# Print squares of numbers from 1 to 5\nfor n in range(1, 6):\n    print(n, \"squared is\", n * n)\n\n\nWhy it Matters\nThe for loop is the most common way to repeat actions in Python when you know how many times to loop. It’s simpler and clearer than a while loop for counting and iterating over ranges.\n\n\nTry It Yourself\n\nWrite a loop that prints numbers 1 through 10.\nUse range() with a step of 2 to print even numbers up to 20.\nWrite a loop that prints \"Python\" five times.\nCreate a loop with range(10, 0, -1) to count down from 10 to 1.\n\n\n\n\n19. Loop Control (break, continue)\nSometimes you need more control over loops. Python provides two special keywords—break and continue—to change how a loop behaves. These allow you to stop a loop early or skip parts of it.\n\nDeep Dive\nbreak — Stop the Loop The break statement ends the loop immediately, even if the loop condition or range still has more values.\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)\n# Output: 0, 1, 2, 3, 4\ncontinue — Skip to Next Iteration The continue statement skips the rest of the loop body and moves to the next iteration.\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)\n# Output: 0, 1, 3, 4\nUsing with while Loops Both break and continue work the same way in while loops.\nx = 0\nwhile x &lt; 5:\n    x += 1\n    if x == 3:\n        continue\n    if x == 5:\n        break\n    print(x)\n# Output: 1, 2, 4\nWhen to Use\n\nbreak is useful when you find what you’re looking for and don’t need to continue looping.\ncontinue is useful when you want to skip over certain cases but still keep looping.\n\n\n\nTiny Code\n# Find first multiple of 7\nfor n in range(1, 20):\n    if n % 7 == 0:\n        print(\"Found:\", n)\n        break\n\n# Print only odd numbers\nfor n in range(1, 10):\n    if n % 2 == 0:\n        continue\n    print(n)\n\n\nWhy it Matters\nWithout loop control, you would have to add extra complicated logic or duplicate code. break and continue give you fine-grained control, making loops cleaner, more efficient, and easier to understand.\n\n\nTry It Yourself\n\nWrite a loop that prints numbers from 1 to 100, but stops when it reaches 42.\nWrite a loop that prints numbers from 1 to 10, but skips multiples of 3.\nCombine both: loop through numbers 1 to 20, skip evens, and stop completely if you find 15.\n\n\n\n\n20. Loop with else\nIn Python, a for or while loop can have an optional else block. The else part runs only if the loop finishes normally—that is, it isn’t stopped early by a break. This feature is unique to Python and is often used when searching for something.\n\nDeep Dive\nBasic Structure\nfor item in sequence:\n    # loop body\nelse:\n    # runs if loop finishes without break\nExample with for\nfor i in range(5):\n    print(i)\nelse:\n    print(\"Loop finished\")\nThis prints numbers 0 through 4, then prints \"Loop finished\".\nUsing with break If the loop ends because of break, the else block is skipped:\nfor i in range(5):\n    if i == 3:\n        break\n    print(i)\nelse:\n    print(\"Finished without break\")\n# Output: 0, 1, 2\nExample with while\nx = 0\nwhile x &lt; 3:\n    print(x)\n    x += 1\nelse:\n    print(\"While loop ended normally\")\nPractical Use Case: Searching The else block is handy when searching for an item. If you find the item, break ends the loop; if not, the else runs.\nnumbers = [1, 2, 3, 4, 5]\n\nfor n in numbers:\n    if n == 7:\n        print(\"Found 7!\")\n        break\nelse:\n    print(\"7 not found\")\n\n\nTiny Code\nfor char in \"Python\":\n    if char == \"x\":\n        print(\"Found x!\")\n        break\nelse:\n    print(\"No x in string\")\n\n\nWhy it Matters\nThe else clause on loops lets you handle the “nothing found” case cleanly without needing extra flags or checks. It makes code shorter and easier to understand when searching or checking conditions across a loop.\n\n\nTry It Yourself\n\nWrite a loop that searches for the number 10 in a list of numbers. If found, print \"Found\". If not, let the else print \"Not found\".\nCreate a while loop that counts from 1 to 5 and uses an else block to print \"Done counting\".\nExperiment with adding break inside your loop to see how it changes whether the else runs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-data-structures",
    "href": "index.html#chapter-3.-data-structures",
    "title": "The Little Book of Python",
    "section": "Chapter 3. Data Structures",
    "text": "Chapter 3. Data Structures\n\n21. Lists (creation & basics)\nA list in Python is an ordered collection of items. Think of it like a container where you can store multiple values in a single variable—numbers, strings, or even other lists. Lists are one of the most commonly used data structures in Python because they’re flexible and easy to work with.\n\nDeep Dive\nCreating Lists You create a list by putting values inside square brackets [], separated by commas:\nfruits = [\"apple\", \"banana\", \"cherry\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\nLists can also be empty:\nempty = []\nLists Are Ordered The items keep the order you put them in. If you create a list [10, 20, 30], Python remembers that order unless you change it.\nLists Can Be Changed (Mutable) Unlike strings or tuples, lists can be modified after creation—you can add, remove, or replace elements.\nAccessing Elements Each item in a list has an index (position), starting at 0:\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(fruits[0])   # \"apple\"\nprint(fruits[2])   # \"cherry\"\nLength of a List You can find out how many items a list has with len():\nprint(len(fruits))  # 3\nQuick Summary Table\n\n\n\nOperation\nExample\nResult\n\n\n\n\nCreate a list\nnums = [1, 2, 3]\n[1, 2, 3]\n\n\nEmpty list\nempty = []\n[]\n\n\nAccess by index\nnums[0]\n1\n\n\nLast element\nnums[-1]\n3\n\n\nLength of list\nlen(nums)\n3\n\n\n\n\n\nTiny Code\ncolors = [\"red\", \"green\", \"blue\"]\n\nprint(colors)        # ['red', 'green', 'blue']\nprint(colors[1])     # 'green'\nprint(len(colors))   # 3\n\n\nWhy it Matters\nLists let you store and organize multiple values in one place. Without lists, you’d need a separate variable for each value, which quickly becomes messy. Lists are the foundation for handling collections of data in Python.\n\n\nTry It Yourself\n\nCreate a list of five animals and print the whole list.\nPrint the first and last element of your list using indexes.\nMake an empty list called shopping_cart and check its length.\nTry storing mixed types in one list (like a number, string, and boolean) and print it.\n\n\n\n\n22. List Indexing & Slicing\nLists in Python are ordered, which means each item has a position (index). You can use indexes to get specific elements, or slices to get parts of the list.\n\nDeep Dive\nIndexing Basics Indexes start at 0 for the first element:\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nprint(fruits[0])   # \"apple\"\nprint(fruits[2])   # \"cherry\"\nNegative indexes count from the end:\nprint(fruits[-1])  # \"date\"\nprint(fruits[-2])  # \"cherry\"\nSlicing Basics Slicing lets you grab a portion of a list. The syntax is:\nlist[start:stop]\nIt includes start but stops just before stop.\nprint(fruits[1:3])   # ['banana', 'cherry']\nIf you leave out start, Python begins at the start of the list:\nprint(fruits[:2])    # ['apple', 'banana']\nIf you leave out stop, Python goes to the end:\nprint(fruits[2:])    # ['cherry', 'date']\nSlicing with Step You can add a third number for step size:\nnumbers = [0, 1, 2, 3, 4, 5]\nprint(numbers[::2])   # [0, 2, 4]\nprint(numbers[1::2])  # [1, 3, 5]\nReversing a list is easy with step -1:\nprint(numbers[::-1])  # [5, 4, 3, 2, 1, 0]\nQuick Summary Table\n\n\n\nOperation\nExample\nResult\n\n\n\n\nFirst element\nfruits[0]\n\"apple\"\n\n\nLast element\nfruits[-1]\n\"date\"\n\n\nSlice (index 1–2)\nfruits[1:3]\n['banana', 'cherry']\n\n\nFrom start to 2\nfruits[:2]\n['apple', 'banana']\n\n\nFrom 2 to end\nfruits[2:]\n['cherry', 'date']\n\n\nEvery 2nd element\nnumbers[::2]\n[0, 2, 4]\n\n\nReverse list\nnumbers[::-1]\n[5, 4, 3, 2, 1, 0]\n\n\n\n\n\nTiny Code\ncolors = [\"red\", \"green\", \"blue\", \"yellow\"]\n\nprint(colors[0])     # red\nprint(colors[-1])    # yellow\nprint(colors[1:3])   # ['green', 'blue']\nprint(colors[::-1])  # ['yellow', 'blue', 'green', 'red']\n\n\nWhy it Matters\nIndexing and slicing make it easy to get exactly the parts of a list you need. Whether you’re grabbing one item, a range of items, or reversing the list, these tools are essential for working with collections of data.\n\n\nTry It Yourself\n\nMake a list of 6 numbers and print the first, third, and last elements.\nSlice your list to get the middle three elements.\nUse slicing with a step of 2 to get every other number.\nReverse the list using slicing and print the result.\n\n\n\n\n23. List Methods (append, extend, etc.)\nLists in Python come with built-in methods that make it easy to add, remove, and modify items. These methods are powerful tools for managing collections of data.\n\nDeep Dive\nAdding Items\n\nappend(x) → adds a single item to the end of the list.\nextend(iterable) → adds multiple items from another list (or any iterable).\ninsert(i, x) → inserts an item at a specific position.\n\nfruits = [\"apple\", \"banana\"]\nfruits.append(\"cherry\")     # ['apple', 'banana', 'cherry']\nfruits.extend([\"date\", \"fig\"])  # ['apple', 'banana', 'cherry', 'date', 'fig']\nfruits.insert(1, \"kiwi\")    # ['apple', 'kiwi', 'banana', 'cherry', 'date', 'fig']\nRemoving Items\n\nremove(x) → removes the first occurrence of x.\npop(i) → removes and returns the item at index i (defaults to last).\nclear() → removes all items.\n\nfruits.remove(\"banana\")   # ['apple', 'kiwi', 'cherry', 'date', 'fig']\nfruits.pop(2)             # removes 'cherry'\nfruits.clear()            # []\nFinding and Counting\n\nindex(x) → returns the position of the first occurrence of x.\ncount(x) → returns how many times x appears.\n\nnums = [1, 2, 2, 3]\nprint(nums.index(2))  # 1\nprint(nums.count(2))  # 2\nSorting and Reversing\n\nsort() → sorts the list in place.\nreverse() → reverses the order of items in place.\nsorted(list) → returns a new sorted list without changing the original.\n\nletters = [\"b\", \"a\", \"d\", \"c\"]\nletters.sort()       # ['a', 'b', 'c', 'd']\nletters.reverse()    # ['d', 'c', 'b', 'a']\nQuick Summary Table\n\n\n\n\n\n\n\n\nMethod\nPurpose\nExample\n\n\n\n\nappend(x)\nAdd one item at the end\nlst.append(5)\n\n\nextend()\nAdd many items\nlst.extend([6,7])\n\n\ninsert()\nInsert at a position\nlst.insert(1, \"hi\")\n\n\nremove(x)\nRemove first matching value\nlst.remove(\"hi\")\n\n\npop(i)\nRemove by index (or last by default)\nlst.pop(0)\n\n\nclear()\nEmpty the list\nlst.clear()\n\n\nindex(x)\nFind index of first match\nlst.index(2)\n\n\ncount(x)\nCount how many times value appears\nlst.count(2)\n\n\nsort()\nSort list in place\nlst.sort()\n\n\nreverse()\nReverse order in place\nlst.reverse()\n\n\n\n\n\nTiny Code\ncolors = [\"red\", \"blue\"]\n\ncolors.append(\"green\")\ncolors.extend([\"yellow\", \"purple\"])\ncolors.insert(2, \"orange\")\n\nprint(colors)  # ['red', 'blue', 'orange', 'green', 'yellow', 'purple']\n\ncolors.remove(\"blue\")\nlast = colors.pop()\nprint(last)    # 'purple'\n\nprint(colors.count(\"red\"))   # 1\ncolors.sort()\nprint(colors)  # ['green', 'orange', 'red', 'yellow']\n\n\nWhy it Matters\nList methods are essential for real-world programming, where data is always changing. Being able to add, remove, and reorder items makes lists versatile tools for tasks like managing to-do lists, processing datasets, or handling user inputs.\n\n\nTry It Yourself\n\nStart with a list of three numbers. Add two more using append() and extend().\nInsert a number at the beginning of the list.\nRemove one number using remove(), then use pop() to remove the last one.\nSort your list and then reverse it. Print the result at each step.\n\n\n\n\n24. Tuples\nA tuple is an ordered collection of items, just like a list, but with one big difference: tuples are immutable. This means once you create a tuple, you cannot change its contents—no adding, removing, or modifying items. Tuples are useful when you want to store data that should not be altered.\n\nDeep Dive\nCreating Tuples You create a tuple using parentheses () instead of square brackets:\nnumbers = (1, 2, 3)\nfruits = (\"apple\", \"banana\", \"cherry\")\nTuples can hold mixed data types just like lists:\nmixed = (1, \"hello\", 3.14, True)\nFor a single-item tuple, you must include a trailing comma:\nsingle = (5,)\nprint(type(single))   # &lt;class 'tuple'&gt;\nAccessing Elements Tuples use the same indexing and slicing as lists:\nprint(fruits[0])     # \"apple\"\nprint(fruits[-1])    # \"cherry\"\nprint(fruits[0:2])   # (\"apple\", \"banana\")\nImmutability You cannot modify a tuple after it’s created:\nfruits[0] = \"pear\"   # ❌ Error: TypeError\nTuple Packing and Unpacking You can pack multiple values into a tuple and unpack them into variables:\npoint = (3, 4)\nx, y = point\nprint(x, y)   # 3 4\nUse Cases\n\nReturning multiple values from a function.\nFixed collections of data (e.g., coordinates, RGB colors).\nKeys in dictionaries (since tuples are hashable, lists are not).\n\nQuick Summary Table\n\n\n\nFeature\nList\nTuple\n\n\n\n\nSyntax\n[1, 2, 3]\n(1, 2, 3)\n\n\nMutability\nMutable (can change)\nImmutable (cannot)\n\n\nMethods\nMany (append, etc.)\nFew (count, index)\n\n\nPerformance\nSlower\nFaster (lightweight)\n\n\n\n\n\nTiny Code\ncolors = (\"red\", \"green\", \"blue\")\n\nprint(colors[1])       # green\nprint(len(colors))     # 3\n\n# Unpacking\nr, g, b = colors\nprint(r, b)            # red blue\n\n# Methods\nprint(colors.index(\"blue\"))  # 2\nprint(colors.count(\"red\"))   # 1\n\n\nWhy it Matters\nTuples give you a safe way to group data that should not be changed, protecting against accidental modifications. They are also slightly faster than lists, making them useful when performance matters and immutability is desired.\n\n\nTry It Yourself\n\nCreate a tuple with three of your favorite foods and print the second one.\nTry changing one element—observe the error.\nUse unpacking to assign a tuple (10, 20, 30) into variables a, b, c.\nCreate a dictionary where the key is a tuple of coordinates (x, y) and the value is a place name.\n\n\n\n\n25. Sets\nA set in Python is an unordered collection of unique items. Sets are useful when you need to store data without duplicates or when you want to perform mathematical operations like union and intersection.\n\nDeep Dive\nCreating Sets You can create a set using curly braces {} or the set() function:\nfruits = {\"apple\", \"banana\", \"cherry\"}\nnumbers = set([1, 2, 3, 2, 1])  # duplicates removed\nprint(numbers)  # {1, 2, 3}\nNo Duplicates If you try to add duplicates, Python automatically ignores them:\ncolors = {\"red\", \"blue\", \"red\"}\nprint(colors)  # {'red', 'blue'}\nUnordered Sets do not preserve order. You cannot access elements by index (set[0] ❌).\nAdding and Removing Items\n\nadd(x) → adds an item.\nupdate(iterable) → adds multiple items.\nremove(x) → removes an item (error if not found).\ndiscard(x) → removes an item (no error if not found).\npop() → removes and returns a random item.\nclear() → removes all items.\n\ns = {1, 2}\ns.add(3)           # {1, 2, 3}\ns.update([4, 5])   # {1, 2, 3, 4, 5}\ns.remove(2)        # {1, 3, 4, 5}\ns.discard(10)      # no error\nMembership Test Checking if an item exists is fast:\nprint(\"apple\" in fruits)  # True\nSet Operations Sets are great for math-like operations:\na = {1, 2, 3}\nb = {3, 4, 5}\n\nprint(a | b)   # union → {1, 2, 3, 4, 5}\nprint(a & b)   # intersection → {3}\nprint(a - b)   # difference → {1, 2}\nprint(a ^ b)   # symmetric difference → {1, 2, 4, 5}\nQuick Summary Table\n\n\n\n\n\n\n\n\n\nOperation\nExample\nResult\n\n\n\n\n\nCreate set\n{1, 2, 3}\n{1, 2, 3}\n\n\n\nAdd item\ns.add(4)\n{1, 2, 3, 4}\n\n\n\nRemove item\ns.remove(2)\nerror if not found\n\n\n\nDiscard item\ns.discard(2)\nsafe remove\n\n\n\nUnion\n`a\nb`\ncombine sets\n\n\nIntersection\na & b\ncommon items\n\n\n\nDifference\na - b\nitems only in a\n\n\n\nSymmetric difference\na ^ b\nitems in a or b, not both\n\n\n\n\n\n\nTiny Code\nnumbers = {1, 2, 3, 3, 2}\nprint(numbers)   # {1, 2, 3}\n\nnumbers.add(4)\nnumbers.discard(1)\nprint(numbers)   # {2, 3, 4}\n\nodds = {1, 3, 5}\nevens = {2, 4, 6}\nprint(odds | evens)   # {1, 2, 3, 4, 5, 6}\n\n\nWhy it Matters\nSets make it easy to eliminate duplicates and perform operations like union or intersection, which are common in data analysis, algorithms, and everyday programming tasks. They are also optimized for fast membership testing.\n\n\nTry It Yourself\n\nCreate a set of your favorite fruits and add a new one.\nTry adding the same fruit again—see how duplicates are ignored.\nMake two sets of numbers and print their union, intersection, and difference.\nUse in to check if an element is in the set.\n\n\n\n\n26. Set Operations (union, intersection)\nSets in Python shine when you use them for mathematical-style operations. They let you combine, compare, and filter items in powerful ways. These operations are very fast and are often used in data processing, searching, and analysis.\n\nDeep Dive\nUnion (| or .union()) The union of two sets contains all unique items from both.\na = {1, 2, 3}\nb = {3, 4, 5}\nprint(a | b)           # {1, 2, 3, 4, 5}\nprint(a.union(b))      # {1, 2, 3, 4, 5}\nIntersection (& or .intersection()) The intersection contains only items present in both sets.\nprint(a & b)           # {3}\nprint(a.intersection(b))  # {3}\nDifference (- or .difference()) The difference contains items in the first set but not the second.\nprint(a - b)           # {1, 2}\nprint(b - a)           # {4, 5}\nSymmetric Difference (^ or .symmetric_difference()) The symmetric difference contains items in either set, but not both.\nprint(a ^ b)           # {1, 2, 4, 5}\nprint(a.symmetric_difference(b))  # {1, 2, 4, 5}\nSubset and Superset Checks\n\na &lt;= b → checks if a is a subset of b.\na &gt;= b → checks if a is a superset of b.\n\nx = {1, 2}\ny = {1, 2, 3}\nprint(x &lt;= y)   # True (x is subset of y)\nprint(y &gt;= x)   # True (y is superset of x)\nQuick Summary Table\n\n\n\n\n\n\n\n\n\n\n\nOperation\nSymbol\nExample\nResult\n\n\n\n\n\n\nUnion\n`\n`\n`a\nb`\nall unique items\n\n\nIntersection\n&\na & b\ncommon items\n\n\n\n\nDifference\n-\na - b\nin a not b\n\n\n\n\nSymmetric difference\n^\na ^ b\nin a or b, not both\n\n\n\n\nSubset\n&lt;=\na &lt;= b\nTrue/False\n\n\n\n\nSuperset\n&gt;=\na &gt;= b\nTrue/False\n\n\n\n\n\n\n\nTiny Code\na = {1, 2, 3}\nb = {3, 4, 5}\n\nprint(\"Union:\", a | b)              # {1, 2, 3, 4, 5}\nprint(\"Intersection:\", a & b)       # {3}\nprint(\"Difference:\", a - b)         # {1, 2}\nprint(\"SymDiff:\", a ^ b)            # {1, 2, 4, 5}\n\nprint(\"Subset?\", {1, 2} &lt;= a)       # True\nprint(\"Superset?\", a &gt;= {2, 3})     # True\n\n\nWhy it Matters\nSet operations allow you to quickly solve problems like finding common elements, removing duplicates, or checking membership across collections. They map directly to real-world logic such as “all users,” “users in both groups,” or “items missing from one list.”\n\n\nTry It Yourself\n\nMake two sets of numbers: {1, 2, 3, 4} and {3, 4, 5, 6}. Find their union, intersection, and difference.\nCreate a set of vowels and a set of letters in the word \"python\". Find the intersection to see which vowels appear.\nCheck if {1, 2} is a subset of {1, 2, 3, 4}.\nTry symmetric difference between {a, b, c} and {b, c, d}.\n\n\n\n\n27. Dictionaries (creation & basics)\nA dictionary in Python is a collection of key–value pairs. Instead of accessing items by index like lists, you access them by their keys. This makes dictionaries very powerful for storing and retrieving data when you want to associate labels with values.\n\nDeep Dive\nCreating Dictionaries You create a dictionary using curly braces {} with keys and values separated by colons:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"Paris\"}\nAccessing Values You get values by their keys, not by position:\nprint(person[\"name\"])   # \"Alice\"\nprint(person[\"age\"])    # 25\nAdding and Updating Dictionaries are mutable—you can add new key–value pairs or update existing ones:\nperson[\"job\"] = \"Engineer\"\nperson[\"age\"] = 26\nKeys Must Be Unique If you repeat a key, the latest value will overwrite the earlier one:\ndata = {\"a\": 1, \"a\": 2}\nprint(data)   # {\"a\": 2}\nDictionary Keys and Values\n\nKeys must be immutable types (strings, numbers, tuples).\nValues can be any type: strings, numbers, lists, or even other dictionaries.\n\nEmpty Dictionary You can start with an empty dictionary:\nempty = {}\nQuick Summary Table\n\n\n\n\n\n\n\n\nOperation\nExample\nResult\n\n\n\n\nCreate dictionary\n{\"a\": 1, \"b\": 2}\n{'a': 1, 'b': 2}\n\n\nAccess by key\nperson[\"name\"]\n\"Alice\"\n\n\nAdd / update\nperson[\"age\"] = 30\nchanges value for \"age\"\n\n\nEmpty dictionary\n{}\n{}\n\n\nMixed values allowed\n{\"id\": 1, \"tags\": [\"x\", \"y\"], \"active\": True}\nvalid dictionary\n\n\n\n\n\nTiny Code\ncar = {\"brand\": \"Toyota\", \"model\": \"Corolla\", \"year\": 2020}\n\nprint(car[\"brand\"])      # Toyota\ncar[\"year\"] = 2021       # update value\ncar[\"color\"] = \"blue\"    # add new key\nprint(car)\n\n\nWhy it Matters\nDictionaries give you a natural way to organize and retrieve data by name instead of position. They are essential for representing structured data, like database records, configurations, or JSON data from APIs.\n\n\nTry It Yourself\n\nCreate a dictionary called student with keys \"name\", \"age\", and \"grade\".\nAccess and print the \"grade\".\nUpdate the \"age\" to a new number.\nAdd a new key \"passed\" with the value True.\nPrint the whole dictionary to see the changes.\n\n\n\n\n28. Dictionary Methods\nDictionaries come with built-in methods that make it easy to work with their keys and values. These methods let you add, remove, and inspect data in a structured way.\n\nDeep Dive\nAccessing Keys, Values, and Items\n\ndict.keys() → returns all keys.\ndict.values() → returns all values.\ndict.items() → returns pairs of (key, value).\n\nperson = {\"name\": \"Alice\", \"age\": 25}\n\nprint(person.keys())    # dict_keys(['name', 'age'])\nprint(person.values())  # dict_values(['Alice', 25])\nprint(person.items())   # dict_items([('name', 'Alice'), ('age', 25)])\nAdding and Updating\n\nupdate(other_dict) → adds or updates key–value pairs.\n\nperson.update({\"age\": 26, \"city\": \"Paris\"})\nRemoving Items\n\npop(key) → removes and returns the value for a key.\npopitem() → removes and returns the last inserted pair.\ndel dict[key] → deletes a key–value pair.\nclear() → empties the dictionary.\n\nprint(person.pop(\"age\"))     # 26\nprint(person.popitem())      # ('city', 'Paris')\ndel person[\"name\"]           # removes \"name\"\nperson.clear()               # {}\nGet with Default\n\nget(key, default) → safely gets a value; returns default if the key doesn’t exist.\n\nperson = {\"name\": \"Alice\"}\nprint(person.get(\"age\", \"Not found\"))  # \"Not found\"\nFrom Keys\n\ndict.fromkeys(keys, value) → creates a dictionary with given keys and default value.\n\nkeys = [\"a\", \"b\", \"c\"]\nprint(dict.fromkeys(keys, 0))   # {'a': 0, 'b': 0, 'c': 0}\nQuick Summary Table\n\n\n\n\n\n\n\n\nMethod\nPurpose\nExample\n\n\n\n\nkeys()\nGet all keys\nperson.keys()\n\n\nvalues()\nGet all values\nperson.values()\n\n\nitems()\nGet all pairs\nperson.items()\n\n\nupdate()\nAdd/update multiple pairs\nperson.update({\"age\": 26})\n\n\npop(key)\nRemove by key, return value\nperson.pop(\"name\")\n\n\npopitem()\nRemove last inserted pair\nperson.popitem()\n\n\nget()\nSafe value access with default\nperson.get(\"city\", \"Unknown\")\n\n\nclear()\nRemove all pairs\nperson.clear()\n\n\nfromkeys()\nCreate new dict from keys\ndict.fromkeys([\"x\", \"y\"], 1)\n\n\n\n\n\nTiny Code\nstudent = {\"name\": \"Bob\", \"age\": 20, \"grade\": \"A\"}\n\nprint(student.keys())       # dict_keys(['name', 'age', 'grade'])\nprint(student.get(\"city\", \"N/A\"))  # N/A\n\nstudent.update({\"age\": 21})\nprint(student)\n\nstudent.pop(\"grade\")\nprint(student)\n\n\nWhy it Matters\nDictionary methods let you manipulate structured data efficiently. Whether you’re cleaning data, merging information, or safely handling missing values, these methods are essential for working with real-world datasets and configurations.\n\n\nTry It Yourself\n\nCreate a dictionary book with \"title\", \"author\", and \"year\".\nUse keys(), values(), and items() to inspect it.\nUpdate the \"year\" to the current year using update().\nUse get() to safely access a missing \"publisher\" key with a default value.\nClear the dictionary with clear().\n\n\n\n\n30. Nested Structures\nA nested structure means putting one data structure inside another—for example, a list of lists, a dictionary containing lists, or even a list of dictionaries. Nested structures are common when representing more complex, real-world data.\n\nDeep Dive\nLists Inside Lists You can create multi-dimensional lists:\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nprint(matrix[0][1])   # 2\nDictionaries with Lists Values in a dictionary can be lists:\nstudent = {\n    \"name\": \"Alice\",\n    \"grades\": [85, 90, 92]\n}\nprint(student[\"grades\"][1])   # 90\nLists of Dictionaries A list can contain multiple dictionaries, useful for structured records:\npeople = [\n    {\"name\": \"Alice\", \"age\": 25},\n    {\"name\": \"Bob\", \"age\": 30}\n]\nprint(people[1][\"name\"])   # Bob\nDictionaries of Dictionaries Dictionaries can be nested, too:\nusers = {\n    \"alice\": {\"age\": 25, \"city\": \"Paris\"},\n    \"bob\": {\"age\": 30, \"city\": \"London\"}\n}\nprint(users[\"bob\"][\"city\"])   # London\nIteration Through Nested Structures You can use loops inside loops to navigate deeper levels:\nfor row in matrix:\n    for val in row:\n        print(val, end=\" \")\nQuick Summary Table\n\n\n\n\n\n\n\n\nNested Type\nExample\nAccess Example\n\n\n\n\nList of lists\n[[1,2],[3,4]]\nx[0][1] → 2\n\n\nDict with list\n{\"scores\":[10,20]}\nd[\"scores\"][0] → 10\n\n\nList of dicts\n[{\"n\":\"a\"},{\"n\":\"b\"}]\nlst[1][\"n\"] → \"b\"\n\n\nDict of dicts\n{\"a\":{\"x\":1}, \"b\":{\"x\":2}}\nd[\"b\"][\"x\"] → 2\n\n\n\n\n\nTiny Code\nclassrooms = {\n    \"A\": [\"Alice\", \"Bob\"],\n    \"B\": [\"Charlie\", \"Diana\"]\n}\n\nfor room, students in classrooms.items():\n    print(\"Room:\", room)\n    for student in students:\n        print(\"-\", student)\n\n\nWhy it Matters\nReal-world data is rarely flat—it’s often hierarchical or structured in layers (like JSON from APIs, database rows with embedded fields, or spreadsheets). Nested structures let you represent and work with this complexity directly in Python.\n\n\nTry It Yourself\n\nCreate a list of lists to represent a 3×3 grid and print the center value.\nMake a dictionary with a key \"friends\" pointing to a list of three names. Print the second name.\nCreate a list of dictionaries, each with \"title\" and \"year\", for your favorite movies. Print the title of the last one.\nBuild a dictionary of dictionaries representing two countries with their capital cities, then print one capital.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-4.-functions",
    "href": "index.html#chapter-4.-functions",
    "title": "The Little Book of Python",
    "section": "Chapter 4. Functions",
    "text": "Chapter 4. Functions\n\n31. Defining a Function (def)\nA function is a reusable block of code that performs a specific task. Functions let you avoid repetition, organize your code, and make programs easier to understand. In Python, you define a function using the def keyword.\n\nDeep Dive\nBasic Function Definition\ndef greet():\n    print(\"Hello!\")\nCalling greet() runs the code inside.\nFunctions with Parameters You can pass data into functions using parameters:\ndef greet(name):\n    print(\"Hello,\", name)\n\ngreet(\"Alice\")   # Hello, Alice\nReturn Values Functions can return data with return:\ndef add(a, b):\n    return a + b\n\nresult = add(3, 4)\nprint(result)   # 7\nDefault Behavior\n\nIf a function doesn’t explicitly return, it returns None.\nFunctions can be defined before or after other code, but must be defined before they are called.\n\nWhy Use Functions?\n\nReusability: write once, use many times.\nReadability: group code into meaningful chunks.\nMaintainability: easier to test and fix.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nNotes\n\n\n\n\nDefine function\ndef f():\nCode block indented\n\n\nCall function\nf()\nExecutes the block\n\n\nWith parameter\ndef f(x):\nPass value when calling\n\n\nWith return\ndef f(x): return x+1\nGives back a value\n\n\nImplicit return\nfunction without return\nReturns None\n\n\n\n\n\nTiny Code\ndef square(n):\n    return n * n\n\nprint(square(5))   # 25\n\ndef welcome(name):\n    print(\"Welcome,\", name)\n\nwelcome(\"Bob\")     # Welcome, Bob\n\n\nWhy it Matters\nFunctions are the building blocks of programs. They let you break down complex problems into smaller pieces, reuse code efficiently, and make your programs easier to maintain and understand.\n\n\nTry It Yourself\n\nWrite a function hello() that prints \"Hello, Python!\".\nWrite a function double(x) that returns twice the number given.\nDefine a function say_name(name) that prints \"My name is ...\" with the input name.\nCall your functions multiple times to see the benefits of reuse.\n\n\n\n\n32. Function Arguments\nFunctions can take arguments (also called parameters) so you can pass information into them. Arguments make functions flexible because they can work with different inputs instead of being hardcoded.\n\nDeep Dive\nPositional Arguments The most common type—values are matched to parameters in order.\ndef greet(name, age):\n    print(\"Hello,\", name, \"you are\", age, \"years old\")\n\ngreet(\"Alice\", 25)\nKeyword Arguments You can pass values by naming the parameters. This makes the call clearer and order doesn’t matter.\ngreet(age=30, name=\"Bob\")\nDefault Arguments You can give parameters default values, making them optional when calling the function.\ndef greet(name, age=18):\n    print(\"Hello,\", name, \"you are\", age)\n\ngreet(\"Charlie\")      # uses default age = 18\ngreet(\"Diana\", 22)    # overrides default\nMixing Arguments When mixing, positional arguments come first, then keyword arguments.\ndef student(name, grade=\"A\"):\n    print(name, \"got grade\", grade)\n\nstudent(\"Eva\")            # Eva got grade A\nstudent(\"Frank\", grade=\"B\")\nWrong Usage Causes Errors\ngreet(25, \"Alice\")   # order matters for positional\nQuick Summary Table\n\n\n\n\n\n\n\n\nType\nExample call\nNotes\n\n\n\n\nPositional\nf(1, 2)\nOrder matters\n\n\nKeyword\nf(b=2, a=1)\nOrder doesn’t matter\n\n\nDefault value\nf(1) when defined as f(a, b=2)\nUses default if missing\n\n\nMixed\nf(1, b=3)\nPositional first, keyword next\n\n\n\n\n\nTiny Code\ndef introduce(name, country=\"Unknown\"):\n    print(\"I am\", name, \"from\", country)\n\nintroduce(\"Alice\")                 # I am Alice from Unknown\nintroduce(\"Bob\", \"France\")         # I am Bob from France\nintroduce(name=\"Charlie\", country=\"Japan\")\n\n\nWhy it Matters\nArguments let you write one function that works in many situations. Instead of duplicating code, you can pass in different values and reuse the same function. This is one of the core ideas of programming.\n\n\nTry It Yourself\n\nWrite a function add(a, b) that prints the sum of two numbers.\nCall it with both positional (add(3, 4)) and keyword (add(b=4, a=3)) arguments.\nCreate a function greet(name=\"Friend\") that has a default value for name. Call it with and without providing the argument.\nWrite a function power(base, exponent=2) that returns base raised to exponent. Call it with one and two arguments.\n\n\n\n\n33. Default & Keyword Arguments\nPython functions can define default values for parameters and accept keyword arguments when called. These features make functions flexible and easier to use by reducing how much you need to type and improving readability.\n\nDeep Dive\nDefault Arguments When defining a function, you can give a parameter a default value. If the caller doesn’t provide it, Python uses the default.\ndef greet(name=\"Friend\"):\n    print(\"Hello,\", name)\n\ngreet()              # Hello, Friend\ngreet(\"Alice\")       # Hello, Alice\nMultiple Defaults You can set defaults for more than one parameter.\ndef connect(host=\"localhost\", port=8080):\n    print(\"Connecting to\", host, \"on port\", port)\n\nconnect()                      # localhost, 8080\nconnect(\"example.com\")         # example.com, 8080\nconnect(port=5000)             # localhost, 5000\nKeyword Arguments When calling a function, you can use parameter names. This makes it clear what each value means, and order doesn’t matter.\ndef introduce(name, age):\n    print(name, \"is\", age, \"years old\")\n\nintroduce(age=30, name=\"Bob\")  # Bob is 30 years old\nMixing Positional and Keyword Arguments You can mix both, but positional arguments must come first.\ndef describe(animal, sound=\"unknown\"):\n    print(animal, \"goes\", sound)\n\ndescribe(\"Dog\")                      # Dog goes unknown\ndescribe(\"Cat\", sound=\"Meow\")        # Cat goes Meow\nImportant Rule Default arguments are evaluated once, when the function is defined. Be careful with mutable defaults like lists or dictionaries—they can persist changes between calls.\ndef add_item(item, container=[]):\n    container.append(item)\n    return container\n\nprint(add_item(1))   # [1]\nprint(add_item(2))   # [1, 2]  ← reused same list!\nThe safe way is:\ndef add_item(item, container=None):\n    if container is None:\n        container = []\n    container.append(item)\n    return container\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nBenefit\n\n\n\n\nDefault parameter\ndef f(x=10)\nOptional arguments\n\n\nKeyword argument call\nf(y=2, x=1)\nClear meaning, order-free\n\n\nMixing positional+keyword\nf(1, y=2)\nFlexible calls\n\n\nMutable default trap\ndef f(lst=[])\nAvoid with None as default\n\n\n\n\n\nTiny Code\ndef greet(name=\"Guest\", lang=\"en\"):\n    if lang == \"en\":\n        print(\"Hello,\", name)\n    elif lang == \"fr\":\n        print(\"Bonjour,\", name)\n    else:\n        print(\"Hi,\", name)\n\ngreet()\ngreet(\"Alice\")\ngreet(\"Bob\", lang=\"fr\")\n\n\nWhy it Matters\nDefault and keyword arguments make functions more user-friendly. They reduce repetitive code, prevent errors from missing values, and improve readability when functions have many parameters.\n\n\nTry It Yourself\n\nWrite a function multiply(a, b=2) that returns a * b. Call it with one argument and with two.\nCreate a function profile(name, age=18, city=\"Unknown\") and call it using keyword arguments in any order.\nTest the mutable default trap by defining a function with list=[]. See how it behaves after multiple calls.\nRewrite it using None as the default and verify the issue is fixed.\n\n\n\n\n34. Return Values\nFunctions don’t just perform actions—they can also send results back using the return statement. This makes functions powerful, because you can store their output, use it in calculations, or pass it into other functions.\n\nDeep Dive\nBasic Return\ndef add(a, b):\n    return a + b\n\nresult = add(3, 4)\nprint(result)   # 7\nWhen Python hits return, the function stops and sends the value back.\nReturning Multiple Values Python functions can return more than one value by returning a tuple:\ndef get_stats(numbers):\n    return min(numbers), max(numbers), sum(numbers) / len(numbers)\n\nlow, high, avg = get_stats([10, 20, 30])\nprint(low, high, avg)   # 10 30 20.0\nNo Return = None If a function doesn’t have a return, it automatically returns None.\ndef say_hello():\n    print(\"Hello\")\n\nresult = say_hello()\nprint(result)   # None\nReturn vs Print\n\nprint() shows something on the screen.\nreturn gives a value back to the program.\n\ndef square(x):\n    return x * x\n\nprint(square(5))   # 25 (returned value printed)\nWithout return, you can’t reuse the result later.\nEarly Return You can use return to exit a function early.\ndef safe_divide(a, b):\n    if b == 0:\n        return \"Cannot divide by zero\"\n    return a / b\nQuick Summary Table\n\n\n\n\n\n\n\n\nBehavior\nExample\nResult\n\n\n\n\nSingle return\nreturn x + y\none value\n\n\nMultiple return\nreturn a, b\ntuple of values\n\n\nNo return\nno return\nNone\n\n\nReturn vs print\nreturn gives data, print shows data\ndifference in purpose\n\n\n\n\n\nTiny Code\ndef cube(n):\n    return n  3\n\ndef min_max(nums):\n    return min(nums), max(nums)\n\nprint(cube(4))             # 64\nlow, high = min_max([3, 7, 2, 9])\nprint(low, high)           # 2 9\n\n\nWhy it Matters\nReturn values make functions reusable building blocks. Instead of just displaying results, functions can calculate and hand back values, letting you compose larger programs from smaller pieces.\n\n\nTry It Yourself\n\nWrite a function square(n) that returns the square of a number.\nCreate a function divide(a, b) that returns the result, but if b is 0, return \"Error\".\nWrite a function circle_area(radius) that returns the area using 3.14 * r * r.\nMake a function that returns both the smallest and largest number from a list.\n\n\n\n\n35. Variable Scope (local vs global)\nIn Python, scope refers to where a variable can be accessed in your code. Variables created inside a function exist only there, while variables created outside are available globally. Understanding scope helps avoid bugs and keeps code organized.\n\nDeep Dive\nLocal Variables A variable created inside a function is local to that function. It only exists while the function runs.\ndef greet():\n    message = \"Hello\"   # local variable\n    print(message)\n\ngreet()\n# print(message) ❌ Error: message not defined\nGlobal Variables A variable created outside functions is global and can be used anywhere.\nname = \"Alice\"   # global variable\n\ndef say_name():\n    print(\"My name is\", name)\n\nsay_name()       # works fine\nLocal vs Global Priority If a local variable has the same name as a global one, Python uses the local one inside the function.\nx = 10   # global\n\ndef show():\n    x = 5   # local\n    print(x)\n\nshow()      # 5\nprint(x)    # 10\nUsing global Keyword If you want to modify a global variable inside a function, use global.\ncount = 0\n\ndef increase():\n    global count\n    count += 1\n\nincrease()\nprint(count)   # 1\nBest Practice\n\nUse local variables whenever possible—they are safer and easier to manage.\nAvoid modifying global variables inside functions unless absolutely necessary.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nVariable Type\nDefined Where\nAccessible Where\n\n\n\n\nLocal\nInside a function\nOnly inside that function\n\n\nGlobal\nOutside functions\nAnywhere in the program\n\n\nShadowing\nLocal overrides global\nLocal used inside function\n\n\nglobal\nMarks variable as global\nAllows modification in function\n\n\n\n\n\nTiny Code\nx = 100   # global\n\ndef test():\n    x = 50   # local\n    print(\"Inside function:\", x)\n\ntest()\nprint(\"Outside function:\", x)\n\n\nWhy it Matters\nScope controls variable visibility and prevents accidental overwriting of values. By understanding local vs global variables, you can write cleaner, more reliable code that avoids confusing bugs.\n\n\nTry It Yourself\n\nCreate a global variable city = \"Paris\" and write a function that prints it.\nDefine a function with a local variable city = \"London\" and see which value prints inside vs outside.\nMake a counter using a global variable and a function that increases it with the global keyword.\nWrite two functions that each define their own local variable with the same name, and confirm they don’t affect each other.\n\n\n\n\n36. *args and kwargs\nIn Python, functions can accept a flexible number of arguments using *args and kwargs. These let you handle situations where you don’t know in advance how many inputs the user will provide.\n\nDeep Dive\n*args → Variable Positional Arguments\n\nCollects extra positional arguments into a tuple.\n\ndef add_all(*args):\n    print(args)\n\nadd_all(1, 2, 3)   # (1, 2, 3)\nYou can loop through args to process them:\ndef add_all(*args):\n    return sum(args)\n\nprint(add_all(1, 2, 3, 4))   # 10\nkwargs → Variable Keyword Arguments\n\nCollects extra keyword arguments into a dictionary.\n\ndef show_info(kwargs):\n    print(kwargs)\n\nshow_info(name=\"Alice\", age=25)\n# {'name': 'Alice', 'age': 25}\nYou can access values like a normal dictionary:\ndef show_info(kwargs):\n    for key, value in kwargs.items():\n        print(key, \"=\", value)\n\nshow_info(city=\"Paris\", country=\"France\")\nCombining *args and kwargs You can use both in the same function, but *args must come before kwargs.\ndef demo(a, *args, kwargs):\n    print(\"a:\", a)\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\n\ndemo(1, 2, 3, x=10, y=20)\n# a: 1\n# args: (2, 3)\n# kwargs: {'x': 10, 'y': 20}\nUnpacking with * and You can also use `*` and to unpack lists/tuples and dictionaries into arguments.\nnums = [1, 2, 3]\nprint(add_all(*nums))   # 6\n\noptions = {\"city\": \"Tokyo\", \"year\": 2025}\nshow_info(options)\nQuick Summary Table\n\n\n\n\n\n\n\n\n\nFeature\nCollects Into\nExample Call\nExample Result\n\n\n\n\n*args\nTuple\nf(1,2,3)\n(1,2,3)\n\n\nkwargs\nDictionary\nf(a=1, b=2)\n{'a':1,'b':2}\n\n\nBoth combined\nargs + kwargs\nf(1,2, x=10)\nargs=(2,), kwargs={'x':10}\n\n\nUnpacking *\nSplits list\nf(*[1,2])\nlike f(1,2)\n\n\nUnpacking `| Splits dict   |f({‘a’:1})| likef(a=1)`\n\n\n\n\n\n\n\n\nTiny Code\ndef greet(*names, options):\n    for name in names:\n        print(\"Hello,\", name)\n    if \"lang\" in options:\n        print(\"Language:\", options[\"lang\"])\n\ngreet(\"Alice\", \"Bob\", lang=\"English\")\n\n\nWhy it Matters\n*args and kwargs make functions more flexible and reusable. They let you handle unknown numbers of inputs, write cleaner APIs, and pass around configurations easily.\n\n\nTry It Yourself\n\nWrite a function multiply_all(*nums) that multiplies any number of values.\nCreate a function print_info(data) that prints each key–value pair.\nCombine them: f(x, *args, kwargs) and test with mixed inputs.\nExperiment with unpacking a list into *args and a dictionary into kwargs.\n\n\n\n\n37. Lambda Functions\nA lambda function is a small, anonymous function defined with the keyword lambda. Unlike normal functions defined with def, lambda functions are written in a single line and don’t need a name unless you assign them to a variable. They’re often used for quick, throwaway functions.\n\nDeep Dive\nBasic Syntax\nlambda arguments: expression\n\narguments → input parameters.\nexpression → a single expression that is evaluated and returned.\n\nExample:\nsquare = lambda x: x * x\nprint(square(5))   # 25\nMultiple Arguments\nadd = lambda a, b: a + b\nprint(add(3, 4))   # 7\nNo Arguments\nhello = lambda: \"Hello!\"\nprint(hello())     # Hello!\nUse with Built-in Functions Lambdas are often used with map(), filter(), and sorted().\n\nWith map() to apply a function to all items:\n\nnums = [1, 2, 3, 4]\nsquares = list(map(lambda x: x * x, nums))\nprint(squares)   # [1, 4, 9, 16]\n\nWith filter() to keep items that match a condition:\n\nevens = list(filter(lambda x: x % 2 == 0, nums))\nprint(evens)   # [2, 4]\n\nWith sorted() to customize sorting:\n\nwords = [\"banana\", \"apple\", \"cherry\"]\nwords.sort(key=lambda w: len(w))\nprint(words)   # ['apple', 'banana', 'cherry']\nLimitations\n\nOnly one expression (no multiple lines).\nCan’t contain statements like print, return, or loops (though you can call functions inside).\nBest for short, simple tasks.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nOutput\n\n\n\n\nSingle argument\nlambda x: x + 1\nAdds 1 to x\n\n\nMultiple args\nlambda a, b: a * b\nMultiplies a and b\n\n\nNo args\nlambda: \"hi\"\nReturns “hi”\n\n\nWith map()\nmap(lambda x: x*x, [1,2])\n[1, 4]\n\n\nWith filter()\nfilter(lambda x: x&gt;2, [1,2,3])\n[3]\n\n\nWith sorted()\nsorted(words, key=lambda w:len(w))\nSorted by length\n\n\n\n\n\nTiny Code\nnums = [5, 10, 15]\n\n# Double numbers using lambda + map\ndoubles = list(map(lambda n: n * 2, nums))\nprint(doubles)   # [10, 20, 30]\n\n# Filter numbers greater than 7\ngreater = list(filter(lambda n: n &gt; 7, nums))\nprint(greater)   # [10, 15]\n\n\nWhy it Matters\nLambda functions let you write short, inline functions without cluttering your code. They’re especially handy for quick data transformations, sorting, and filtering when defining a full function would be unnecessary.\n\n\nTry It Yourself\n\nWrite a lambda function that adds 10 to a number.\nUse a lambda with filter() to keep only odd numbers from a list.\nSort a list of names by their last letter using sorted() with a lambda key.\nUse map() with a lambda to convert a list of Celsius temperatures into Fahrenheit.\n\n\n\n\n38. Docstrings\nA docstring (documentation string) is a special string placed inside functions, classes, or modules to explain what they do. Unlike comments, docstrings are stored at runtime and can be accessed with tools like help(). They are a key part of writing clean, professional Python code.\n\nDeep Dive\nBasic Function Docstring Docstrings are written using triple quotes (\"\"\" ... \"\"\" or ''' ... ''') right below the function definition:\ndef greet(name):\n    \"\"\"Return a greeting message for the given name.\"\"\"\n    return \"Hello, \" + name\nAccessing Docstrings You can retrieve the docstring with:\nprint(greet.__doc__)\nhelp(greet)\nMulti-Line Docstrings For more complex functions, use multiple lines:\ndef add(a, b):\n    \"\"\"\n    Add two numbers and return the result.\n\n    Parameters:\n        a (int or float): First number.\n        b (int or float): Second number.\n\n    Returns:\n        int or float: The sum of a and b.\n    \"\"\"\n    return a + b\nDocstrings for Classes and Modules\n\nFor classes:\n\nclass Person:\n    \"\"\"A simple class representing a person.\"\"\"\n    def __init__(self, name):\n        self.name = name\n\nFor modules (at the very top of a file):\n\n\"\"\"\nThis module provides math helper functions\nlike factorial and Fibonacci.\n\"\"\"\nPEP 257 Conventions Python has conventions for docstrings:\n\nStart with a short summary in one line.\nLeave a blank line after the summary if you add more detail.\nUse triple quotes even for one-liners.\n\nQuick Summary Table\n\n\n\nWhere Used\nExample Placement\nPurpose\n\n\n\n\nFunction\nInside function body\nExplain what it does/returns\n\n\nClass\nInside class definition\nDescribe the class purpose\n\n\nModule\nAt top of file\nOverview of the whole module\n\n\nAccessing\nobj.__doc__, help()\nSee documentation\n\n\n\n\n\nTiny Code\ndef factorial(n):\n    \"\"\"Calculate the factorial of n using recursion.\"\"\"\n    return 1 if n == 0 else n * factorial(n - 1)\n\nprint(factorial.__doc__)\n\n\nWhy it Matters\nDocstrings turn your code into self-documenting programs. They help others (and your future self) understand how functions, classes, and modules should be used without reading all the code. Tools like Sphinx and IDEs also use docstrings to generate documentation automatically.\n\n\nTry It Yourself\n\nWrite a function square(n) with a one-line docstring explaining what it does.\nCreate a function divide(a, b) with a multi-line docstring that explains parameters and return value.\nAdd a class Car with a docstring describing its purpose.\nUse help() on your function or class to see the docstring displayed.\n\n\n\n\n39. Recursive Functions\nA recursive function is a function that calls itself in order to solve a problem. Recursion is useful when a problem can be broken down into smaller, similar subproblems—like calculating factorials, traversing trees, or solving puzzles.\n\nDeep Dive\nBasic Structure A recursive function always has two parts:\n\nBase case → the condition that stops the recursion.\nRecursive case → the function calls itself with a smaller/simpler problem.\n\ndef countdown(n):\n    if n == 0:             # base case\n        print(\"Done!\")\n    else:\n        print(n)\n        countdown(n - 1)   # recursive case\nExample 1: Factorial The factorial of n is n * (n-1) * (n-2) * ... * 1.\ndef factorial(n):\n    if n == 0:     # base case\n        return 1\n    return n * factorial(n - 1)   # recursive case\n\nprint(factorial(5))   # 120\nExample 2: Fibonacci Sequence Each Fibonacci number is the sum of the previous two.\ndef fib(n):\n    if n &lt;= 1:   # base case\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nprint(fib(6))   # 8\nPotential Issues\n\nInfinite recursion: forgetting a base case causes the function to call itself forever, leading to an error (RecursionError).\nPerformance: recursion can be slower and use more memory than loops for large inputs.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nTerm\nMeaning\nExample\n\n\n\n\nBase case\nCondition that stops recursion\nif n == 0: return 1\n\n\nRecursive case\nFunction calls itself with smaller input\nreturn n * f(n-1)\n\n\nInfinite recursion\nMissing/incorrect base case\nError: never ends\n\n\nUse cases\nFactorial, Fibonacci, tree traversal\nMany algorithmic problems\n\n\n\n\n\nTiny Code\ndef sum_list(numbers):\n    if not numbers:       # base case\n        return 0\n    return numbers[0] + sum_list(numbers[1:])  # recursive case\n\nprint(sum_list([1, 2, 3, 4]))   # 10\n\n\nWhy it Matters\nRecursive functions let you write elegant, natural solutions to problems that involve repetition with smaller pieces—like mathematical sequences, hierarchical data, or divide-and-conquer algorithms.\n\n\nTry It Yourself\n\nWrite a recursive function countdown(n) that prints numbers down to 0.\nCreate a recursive function factorial(n) and test it with n=5.\nWrite a recursive function fib(n) to compute Fibonacci numbers.\nChallenge: Write a recursive function that calculates the sum of all numbers in a list.\n\n\n\n\n40. Higher-Order Functions\nA higher-order function is a function that either takes another function as an argument, returns a function, or both. This makes Python very powerful for writing flexible and reusable code.\n\nDeep Dive\nFunctions as Arguments Since functions are objects in Python, you can pass them around like variables.\ndef apply_twice(func, x):\n    return func(func(x))\n\ndef square(n):\n    return n * n\n\nprint(apply_twice(square, 2))   # 16\nFunctions Returning Functions A function can also create and return another function.\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ndouble = make_multiplier(2)\nprint(double(5))   # 10\nBuilt-in Higher-Order Functions Python provides many built-in higher-order functions:\n\nmap(func, iterable) → applies a function to each item.\n\nnums = [1, 2, 3]\nsquares = list(map(lambda x: x * x, nums))\nprint(squares)   # [1, 4, 9]\n\nfilter(func, iterable) → keeps only items where the function returns True.\n\nevens = list(filter(lambda x: x % 2 == 0, nums))\nprint(evens)   # [2]\n\nsorted(iterable, key=func) → sorts by a custom key.\n\nwords = [\"banana\", \"apple\", \"cherry\"]\nprint(sorted(words, key=len))   # ['apple', 'banana', 'cherry']\n\nreduce(func, iterable) from functools → applies a rolling computation.\n\nfrom functools import reduce\nproduct = reduce(lambda a, b: a * b, [1, 2, 3, 4])\nprint(product)   # 24\nWhy Use Higher-Order Functions?\n\nThey allow abstraction: write logic once and reuse it.\nThey make code shorter and cleaner.\nThey are the foundation of functional programming.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nFunction as argument\napply_twice(square, 2)\nPass function in\n\n\nFunction as return value\nmake_multiplier(3)\nGenerate new function\n\n\nmap()\nmap(lambda x:x+1, [1,2])\nApply function to items\n\n\nfilter()\nfilter(lambda x:x&gt;2, [1,2,3])\nKeep items meeting condition\n\n\nsorted(..., key=func)\nsorted(words, key=len)\nCustom sorting\n\n\nreduce()\nreduce(lambda a,b:a*b, nums)\nAccumulate values\n\n\n\n\n\nTiny Code\ndef shout(text):\n    return text.upper()\n\ndef whisper(text):\n    return text.lower()\n\ndef speak(func, message):\n    print(func(message))\n\nspeak(shout, \"Hello\")\nspeak(whisper, \"Hello\")\n\n\nWhy it Matters\nHigher-order functions let you treat behavior as data. Instead of hardcoding actions, you can pass in functions to customize behavior. This leads to more flexible, reusable, and expressive programs.\n\n\nTry It Yourself\n\nWrite a function apply(func, values) that applies func to every item in values (like your own map).\nUse filter() with a lambda to keep only numbers greater than 10 from a list.\nWrite a make_adder(n) function that returns a new function adding n to its input.\nUse reduce() to calculate the sum of a list of numbers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-5.-modules-and-packages",
    "href": "index.html#chapter-5.-modules-and-packages",
    "title": "The Little Book of Python",
    "section": "Chapter 5. Modules and Packages",
    "text": "Chapter 5. Modules and Packages\n\n41. Importing Modules\nA module in Python is a file containing Python code (functions, classes, variables) that you can reuse in other programs. Importing a module lets you use its code without rewriting it.\n\nDeep Dive\nBasic Import Use the import keyword followed by the module name:\nimport math\n\nprint(math.sqrt(16))   # 4.0\nHere, math is a built-in module that provides mathematical functions.\nImporting Multiple Modules You can import more than one module in one line:\nimport math, random\n\nprint(random.randint(1, 6))   # random number between 1 and 6\nAccessing Module Contents To use something from a module, write module_name.item.\nprint(math.pi)      # 3.14159...\nprint(math.factorial(5))   # 120\nImport Once Only A module is loaded once per program run, even if imported multiple times.\nWhere Python Looks for Modules\n\nThe current working directory.\nInstalled packages (like built-ins).\nPaths defined in sys.path.\n\nYou can check where modules are loaded from:\nimport sys\nprint(sys.path)\nQuick Summary Table\n\n\n\nStatement\nMeaning\n\n\n\n\nimport math\nImport the whole module\n\n\nmath.sqrt(25)\nAccess function using module.function\n\n\nimport a, b\nImport multiple modules at once\n\n\nsys.path\nShows module search paths\n\n\n\n\n\nTiny Code\nimport math\n\nradius = 3\narea = math.pi * (radius  2)\nprint(\"Circle area:\", area)\n\n\nWhy it Matters\nModules let you reuse existing solutions instead of reinventing the wheel. With imports, you can access thousands of built-in and third-party libraries that extend Python’s power for math, networking, data science, and more.\n\n\nTry It Yourself\n\nImport the math module and calculate the square root of 49.\nImport the random module and generate a random integer between 1 and 100.\nUse math.pi to compute the area of a circle with radius 10.\nPrint out the list of paths from sys.path and check where Python looks for modules.\n\n\n\n\n42. Built-in Modules (math, random)\nPython comes with many built-in modules that provide ready-to-use functionality. Two of the most commonly used are math (for mathematical operations) and random (for random number generation).\n\nDeep Dive\nThe math Module Provides advanced mathematical functions.\nCommonly used functions and constants:\nimport math\n\nprint(math.sqrt(25))     # 5.0\nprint(math.pow(2, 3))    # 8.0\nprint(math.factorial(5)) # 120\nprint(math.pi)           # 3.141592653589793\nprint(math.e)            # 2.718281828459045\nOther useful functions:\n\nmath.ceil(x) → round up.\nmath.floor(x) → round down.\nmath.log(x, base) → logarithm.\nmath.sin(x), math.cos(x) → trigonometry.\n\nThe random Module Used for randomness in numbers, selections, and shuffling.\nExamples:\nimport random\n\nprint(random.random())        # random float [0, 1)\nprint(random.randint(1, 6))   # random integer between 1 and 6\nprint(random.choice([\"red\", \"blue\", \"green\"]))  # random choice\nOther useful functions:\n\nrandom.shuffle(list) → shuffle a list in place.\nrandom.uniform(a, b) → random float between a and b.\nrandom.sample(population, k) → pick k unique items.\n\nQuick Summary Table\n\n\n\nModule\nFunction\nExample\nResult\n\n\n\n\nmath\nmath.sqrt(16)\nsquare root\n4.0\n\n\nmath\nmath.ceil(2.3)\nround up\n3\n\n\nmath\nmath.pi\nconstant π\n3.14159...\n\n\nrandom\nrandom.random()\nfloat 0–1\ne.g. 0.732\n\n\nrandom\nrandom.randint(1,10)\nrandom int\nbetween 1 and 10\n\n\nrandom\nrandom.choice(seq)\nrandom element\none from list\n\n\nrandom\nrandom.shuffle(seq)\nshuffle list\nreorders in place\n\n\n\n\n\nTiny Code\nimport math, random\n\n# math example\nprint(\"Cos(0):\", math.cos(0))\n\n# random example\ncolors = [\"red\", \"green\", \"blue\"]\nrandom.shuffle(colors)\nprint(\"Shuffled colors:\", colors)\n\n\nWhy it Matters\nBuilt-in modules like math and random save you from writing code from scratch. They provide reliable, optimized tools for tasks you’ll use frequently, from calculating areas to simulating dice rolls.\n\n\nTry It Yourself\n\nUse math.factorial(6) to calculate 6!.\nGenerate a random float between 5 and 10 using random.uniform().\nCreate a list of 5 numbers, shuffle it, and print the result.\nUse random.sample(range(1, 50), 6) to simulate lottery numbers.\n\n\n\n\n43. Aliasing Imports (import ... as ...)\nSometimes module names are long, or you want a shorter name for convenience. Python allows you to alias a module (or part of it) using as. This doesn’t change the module—it just gives it a nickname in your code.\n\nDeep Dive\nBasic Aliasing\nimport math as m\n\nprint(m.sqrt(16))   # 4.0\nprint(m.pi)         # 3.14159...\nHere, instead of typing math every time, you can use m.\nAliasing Specific Functions You can alias a single function too:\nfrom math import factorial as fact\n\nprint(fact(5))   # 120\nCommon Conventions Some libraries have standard aliases that are widely used in the Python community:\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nThese conventions make code more readable because most developers recognize them instantly.\nWhy Use Aliases?\n\nShorter code → no need to write long names.\nAvoid conflicts → if two modules have the same function name, aliasing prevents confusion.\nReadability → follow community conventions.\n\nQuick Summary Table\n\n\n\nStatement\nMeaning\n\n\n\n\nimport module as alias\ngive module a short name\n\n\nfrom module import f as alias\ngive function a short name\n\n\nimport numpy as np\ncommunity standard alias\n\n\n\n\n\nTiny Code\nimport random as r\n\nprint(r.randint(1, 10))\n\nfrom math import sqrt as root\nprint(root(81))   # 9.0\n\n\nWhy it Matters\nAliasing helps keep code neat, prevents naming conflicts, and improves readability—especially when using popular libraries with well-known abbreviations.\n\n\nTry It Yourself\n\nImport the math module as m and compute m.sin(0).\nImport random.randint as dice and use it to simulate rolling a dice.\nImport math.log as logarithm and compute logarithm(100, 10).\nThink about why import pandas as pd is preferred in community codebases.\n\n\n\n\n44. Importing Specific Functions\nInstead of importing an entire module, you can import only the functions or variables you need. This makes code shorter and sometimes clearer.\n\nDeep Dive\nBasic Syntax\nfrom math import sqrt, pi\n\nprint(sqrt(25))   # 5.0\nprint(pi)         # 3.14159...\nHere, we can use sqrt and pi directly without prefixing them with math..\nImport with Aliases You can also alias imported items:\nfrom math import factorial as fact\n\nprint(fact(5))   # 120\nImporting Everything (Not Recommended) Using * imports all names from a module:\nfrom math import *\nprint(sin(0))   # 0.0\nThis works, but it’s discouraged because:\n\nIt clutters your namespace with too many names.\nYou might overwrite existing variables/functions by accident.\n\nWhen to Import Specific Functions\n\nWhen you only need a small part of a large module.\nWhen you want shorter code without repeating the module name.\nWhen clarity matters more than knowing the source module.\n\nQuick Summary Table\n\n\n\nStatement\nMeaning\n\n\n\n\nfrom math import sqrt\nImport only sqrt\n\n\nfrom math import sqrt, pi\nImport multiple names\n\n\nfrom math import factorial as f\nImport with alias\n\n\nfrom math import *\nImport all (not recommended)\n\n\n\n\n\nTiny Code\nfrom random import choice, randint\n\ncolors = [\"red\", \"green\", \"blue\"]\nprint(choice(colors))       # random color\nprint(randint(1, 6))        # random number 1–6\n\n\nWhy it Matters\nImporting specific functions makes code more concise and sometimes faster to read. It’s especially useful when you’re using only a few tools from a module instead of the whole thing.\n\n\nTry It Yourself\n\nImport only sqrt and pow from math and use them to calculate sqrt(16) and 2^5.\nImport randint from random and simulate rolling two dice.\nImport pi from math and compute the circumference of a circle with radius 7.\nTry using from math import *—then explain why this could cause confusion in larger programs.\n\n\n\n\n45. dir() and help()\nPython provides built-in functions like dir() and help() to let you explore modules, objects, and their available functionality. These are extremely useful when you’re learning or working with unfamiliar code.\n\nDeep Dive\ndir() → List Attributes dir(object) returns a list of all attributes (functions, variables, classes) that an object has.\nExample with a module:\nimport math\nprint(dir(math))\nThis will show a list like:\n['acos', 'asin', 'atan', 'ceil', 'cos', 'e', 'pi', 'sqrt', ...]\nExample with a list:\nnums = [1, 2, 3]\nprint(dir(nums))\nThis shows available list methods such as append, extend, sort.\nhelp() → Documentation help(object) gives a detailed explanation, including docstrings, arguments, and usage.\nExample with a module:\nimport random\nhelp(random.randint)\nThis will display documentation:\nrandint(a, b)\n    Return a random integer N such that a &lt;= N &lt;= b.\nCombining Both\n\nUse dir() to discover what functions exist.\nUse help() to learn how a specific one works.\n\nQuick Summary Table\n\n\n\nFunction\nPurpose\nExample\n\n\n\n\ndir(obj)\nLists all attributes/methods\ndir(math)\n\n\nhelp(obj)\nShows documentation of an object\nhelp(str.upper)\n\n\n\n\n\nTiny Code\nimport math\n\nprint(\"Attributes in math:\", dir(math)[:5])   # show first 5 only\nhelp(math.sqrt)   # show docstring for sqrt\n\n\nWhy it Matters\nInstead of searching online every time, you can use dir() and help() inside Python itself. This makes learning, debugging, and exploring modules much faster.\n\n\nTry It Yourself\n\nUse dir(str) to see what methods strings have.\nPick one (like .split) and call help(str.split).\nImport the random module and run dir(random)—see how many functions it provides.\nUse help(random.choice) to understand how it works.\n\n\n\n\n46. Creating Your Own Module\nA module is just a Python file that you can reuse in other programs. By creating your own module, you can organize code into separate files, making projects easier to maintain and share.\n\nDeep Dive\nStep 1: Write a Module Any .py file can act as a module. Example — create a file called mymath.py:\n# mymath.py\ndef add(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\nStep 2: Import the Module In another Python file (or interactive shell):\nimport mymath\n\nprint(mymath.add(2, 3))       # 5\nprint(mymath.multiply(4, 5))  # 20\nStep 3: Import Specific Functions\nfrom mymath import add\n\nprint(add(10, 20))   # 30\nStep 4: Module Location Python looks for modules in the current folder first, then in installed libraries (sys.path). If your module is in the same directory, you can import it directly.\nSpecial Variable: __name__ Inside every module, Python sets a special variable __name__.\n\nIf the module is run directly: __name__ == \"__main__\".\nIf the module is imported: __name__ == \"module_name\".\n\nThis lets you write code that runs only when the file is executed, not when it’s imported.\n# mymath.py\ndef add(a, b):\n    return a + b\n\nif __name__ == \"__main__\":\n    print(\"Testing add:\", add(2, 3))\nQuick Summary Table\n\n\n\nStep\nExample\n\n\n\n\nCreate file\nmymath.py\n\n\nImport whole module\nimport mymath\n\n\nImport specific function\nfrom mymath import add\n\n\nCheck module search path\nimport sys; print(sys.path)\n\n\nRun directly check\nif __name__ == \"__main__\": ...\n\n\n\n\n\nTiny Code\n# File: greetings.py\ndef hello(name):\n    return f\"Hello, {name}!\"\n\n# File: main.py\nimport greetings\nprint(greetings.hello(\"Alice\"))\n\n\nWhy it Matters\nCreating your own modules lets you structure larger projects, reuse code across different scripts, and share your work with others. It’s the foundation for building Python packages and libraries.\n\n\nTry It Yourself\n\nCreate a file calculator.py with functions add, subtract, multiply, and divide.\nImport it in a separate file and test each function.\nAdd a test block using if __name__ == \"__main__\": that runs some examples when executed directly.\nCreate another module (e.g., greetings.py) and practice importing both in a single script.\n\n\n\n\n47. Understanding Packages\nA package is a way to organize related modules into a directory. Unlike a single module (a .py file), a package is a folder that contains an extra file called __init__.py. This tells Python to treat the folder as a package.\n\nDeep Dive\nBasic Structure\nmypackage/\n    __init__.py\n    math_utils.py\n    string_utils.py\n\n__init__.py → can be empty, or it can define what gets imported when the package is used.\nmath_utils.py and string_utils.py → normal Python modules.\n\nImporting from a Package\nimport mypackage.math_utils\n\nprint(mypackage.math_utils.add(2, 3))\nUsing from ... import ...\nfrom mypackage import string_utils\nprint(string_utils.reverse(\"hello\"))\nImporting Functions Directly\nfrom mypackage.math_utils import add\nprint(add(5, 6))\n__init__.py Role If __init__.py includes imports, you can simplify usage:\n# mypackage/__init__.py\nfrom .math_utils import add\nfrom .string_utils import reverse\nNow you can do:\nfrom mypackage import add, reverse\nNested Packages Packages can contain sub-packages:\nmypackage/\n    __init__.py\n    utils/\n        __init__.py\n        file_utils.py\nAccess with:\nimport mypackage.utils.file_utils\nQuick Summary Table\n\n\n\nTerm\nMeaning\n\n\n\n\nModule\nSingle .py file\n\n\nPackage\nDirectory with __init__.py + modules\n\n\nSub-package\nPackage inside another package\n\n\nImport\nimport mypackage.module\n\n\nSimplify import\nDefine exports in __init__.py\n\n\n\n\n\nTiny Code\nmypackage/\n    __init__.py\n    greetings.py\n# greetings.py\ndef hello(name):\n    return f\"Hello, {name}!\"\n\n# main.py\nfrom mypackage import greetings\nprint(greetings.hello(\"Alice\"))\n\n\nWhy it Matters\nPackages make it easy to organize large projects into smaller, logical parts. They allow you to group related modules together, keep code clean, and make it reusable for others.\n\n\nTry It Yourself\n\nCreate a folder shapes/ with __init__.py and a module circle.py that has area(r).\nImport circle in another file and test the function.\nAdd another module square.py with area(s) and import both.\nModify __init__.py so you can do from shapes import area for both circle and square.\n\n\n\n\n48. Using pip to Install Packages\nWhile Python’s standard library is powerful, you’ll often need third-party packages. Python uses pip (Python Package Installer) to download and manage these packages from the Python Package Index (PyPI).\n\nDeep Dive\nCheck if pip is Installed Most modern Python versions include it by default. You can check with:\npip --version\nInstalling a Package\npip install requests\nThis downloads and installs the popular requests library for making HTTP requests.\nUsing the Installed Package\nimport requests\n\nresponse = requests.get(\"https://api.github.com\")\nprint(response.status_code)   # 200\nUpgrading a Package\npip install --upgrade requests\nUninstalling a Package\npip uninstall requests\nListing Installed Packages\npip list\nSearch for Packages\npip search numpy\nRequirements File You can save dependencies in a file (requirements.txt) so others can install them easily:\nrequests==2.31.0\nnumpy&gt;=1.25\nInstall everything at once:\npip install -r requirements.txt\nQuick Summary Table\n\n\n\nCommand\nPurpose\n\n\n\n\npip install package\nInstall a package\n\n\npip install --upgrade package\nUpdate a package\n\n\npip uninstall package\nRemove a package\n\n\npip list\nShow installed packages\n\n\npip freeze &gt; requirements.txt\nSave current dependencies\n\n\npip install -r requirements.txt\nInstall from requirements file\n\n\n\n\n\nTiny Code\nimport numpy as np\n\narr = np.array([1, 2, 3])\nprint(\"Array:\", arr)\n\n\nWhy it Matters\npip opens the door to Python’s massive ecosystem. Whether you need data analysis (pandas), machine learning (scikit-learn), or web frameworks (Flask, Django), you can install them in seconds and start building.\n\n\nTry It Yourself\n\nRun pip list to see what’s already installed.\nInstall the requests package and use it to fetch a webpage.\nInstall pandas and create a simple DataFrame.\nExport your current environment with pip freeze &gt; requirements.txt and share it with a friend.\n\n\n\n\n49. Virtual Environments\nA virtual environment is a self-contained directory that holds a specific Python version and its installed packages. It allows you to isolate dependencies for different projects so they don’t conflict with each other.\n\nDeep Dive\nWhy Virtual Environments?\n\nDifferent projects may need different versions of the same library.\nPrevents conflicts between global and project-specific packages.\nKeeps your system Python clean.\n\nCreating a Virtual Environment Use the built-in venv module:\npython -m venv myenv\nThis creates a folder myenv/ with its own Python interpreter and libraries.\nActivating the Environment\n\nOn Windows:\n\nmyenv\\Scripts\\activate\n\nOn Mac/Linux:\n\nsource myenv/bin/activate\nYou’ll see (myenv) appear in your terminal prompt, showing it’s active.\nInstalling Packages Inside Once activated, use pip normally—it only affects this environment:\npip install requests\nDeactivating the Environment\ndeactivate\nThis returns you to the system Python.\nRemoving the Environment Just delete the folder myenv/—it’s safe.\nQuick Summary Table\n\n\n\nCommand\nPurpose\n\n\n\n\npython -m venv myenv\nCreate a virtual environment\n\n\nsource myenv/bin/activate\nActivate (Mac/Linux)\n\n\nmyenv\\Scripts\\activate\nActivate (Windows)\n\n\npip install package\nInstall inside environment\n\n\ndeactivate\nExit environment\n\n\n\n\n\nTiny Code\n# Create and activate environment\npython -m venv env_demo\nsource env_demo/bin/activate   # Linux/Mac\n\npip install numpy\npython -c \"import numpy; print(numpy.__version__)\"\n\n\nWhy it Matters\nVirtual environments are essential for professional Python development. They ensure each project has the right dependencies and prevent “it works on my machine” problems.\n\n\nTry It Yourself\n\nCreate a new virtual environment called project_env.\nActivate it and install pandas.\nVerify by importing pandas in Python.\nDeactivate, then delete the folder to remove the environment.\n\n\n\n\n50. Popular Third-Party Packages (Overview)\nBeyond the Python standard library, the community has built thousands of powerful third-party packages available through PyPI (Python Package Index). These extend Python’s capabilities for web development, data analysis, machine learning, automation, and more.\n\nDeep Dive\nWeb Development\n\nFlask → lightweight framework for web apps.\nDjango → full-featured framework for large projects.\n\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    return \"Hello, Flask!\"\nData Science & Analysis\n\nNumPy → arrays and fast math operations.\nPandas → dataframes for data analysis.\nMatplotlib / Seaborn → visualization and charts.\n\nimport pandas as pd\n\ndata = {\"Name\": [\"Alice\", \"Bob\"], \"Age\": [25, 30]}\ndf = pd.DataFrame(data)\nprint(df)\nMachine Learning & AI\n\nscikit-learn → machine learning algorithms.\nTensorFlow / PyTorch → deep learning libraries.\n\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\nNetworking & APIs\n\nRequests → simple HTTP requests.\nFastAPI → modern web APIs with async support.\n\nAutomation & Scripting\n\nBeautifulSoup → web scraping.\nopenpyxl → Excel file automation.\nschedule → lightweight task scheduler.\n\nWhy Use Third-Party Packages?\n\nSave time → no need to reinvent the wheel.\nTested & optimized → reliable, community-supported.\nEcosystem → Python’s real power comes from these packages.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nArea\nPopular Packages\nUse Case\n\n\n\n\nWeb Development\nFlask, Django, FastAPI\nBuild websites & APIs\n\n\nData Analysis\nNumPy, Pandas, Matplotlib, Seaborn\nProcess & visualize data\n\n\nMachine Learning\nscikit-learn, TensorFlow, PyTorch\nML & deep learning\n\n\nAutomation\nRequests, BeautifulSoup, openpyxl\nHTTP, scraping, Excel automation\n\n\n\n\n\nTiny Code\nimport requests\n\nresponse = requests.get(\"https://api.github.com\")\nprint(\"Status:\", response.status_code)\n\n\nWhy it Matters\nThird-party packages are what make Python one of the most popular languages today. Whether you want to build websites, analyze data, or train AI models, there’s a package ready to help you.\n\n\nTry It Yourself\n\nUse pip install requests and fetch data from any website.\nInstall pandas and create a small table of data.\nInstall matplotlib and draw a simple line chart.\nExplore PyPI (https://pypi.org) and find a package that interests you.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-6.-file-handling",
    "href": "index.html#chapter-6.-file-handling",
    "title": "The Little Book of Python",
    "section": "Chapter 6. File Handling",
    "text": "Chapter 6. File Handling\n\n51. Opening Files (open)\nWorking with files is a core part of programming. Python’s built-in open() function lets you read from and write to files easily.\n\nDeep Dive\nBasic Syntax\nfile = open(\"example.txt\", \"mode\")\n\n\"example.txt\" → the file name (with path if needed).\n\"mode\" → tells Python how to open the file.\n\nCommon modes:\n\n\"r\" → read (default).\n\"w\" → write (creates/overwrites file).\n\"a\" → append (adds to file).\n\"b\" → binary mode (e.g., images).\n\"r+\" → read and write.\n\nExample: Opening for Reading\nfile = open(\"example.txt\", \"r\")\ncontent = file.read()\nprint(content)\nfile.close()\nExample: Opening for Writing\nfile = open(\"new.txt\", \"w\")\nfile.write(\"Hello, Python!\\n\")\nfile.close()\nFile Closing Always close files after use with file.close().\n\nThis frees system resources.\nEnsures data is written properly.\n\nError Handling If the file doesn’t exist in \"r\" mode, Python raises an error:\nopen(\"missing.txt\", \"r\")  # FileNotFoundError\nQuick Summary Table\n\n\n\nMode\nMeaning\nExample\n\n\n\n\n\"r\"\nRead (default)\nopen(\"f.txt\", \"r\")\n\n\n\"w\"\nWrite (overwrite)\nopen(\"f.txt\", \"w\")\n\n\n\"a\"\nAppend\nopen(\"f.txt\", \"a\")\n\n\n\"b\"\nBinary\nopen(\"img.png\", \"rb\")\n\n\n\"r+\"\nRead + Write\nopen(\"f.txt\", \"r+\")\n\n\n\n\n\nTiny Code\n# Write a file\nf = open(\"hello.txt\", \"w\")\nf.write(\"Hello, world!\")\nf.close()\n\n# Read the file\nf = open(\"hello.txt\", \"r\")\nprint(f.read())\nf.close()\n\n\nWhy it Matters\nFiles let you store information permanently. Whether saving logs, configurations, or datasets, file handling is essential for almost every real-world Python project.\n\n\nTry It Yourself\n\nCreate a file notes.txt and write three lines of text into it.\nReopen the file in \"r\" mode and print the contents.\nOpen the same file in \"a\" mode and add another line.\nTry opening a non-existent file in \"r\" mode and see the error.\n\n\n\n\n52. Reading Files\nOnce you open a file in read mode, you can extract its contents in different ways depending on your needs: the whole file, line by line, or into a list.\n\nDeep Dive\nRead the Entire File\nf = open(\"notes.txt\", \"r\")\ncontent = f.read()\nprint(content)\nf.close()\n\nf.read() → returns the whole file as a single string.\n\nRead One Line at a Time\nf = open(\"notes.txt\", \"r\")\nline1 = f.readline()\nline2 = f.readline()\nprint(line1, line2)\nf.close()\n\nEach call to readline() gets the next line (including the \\n).\n\nRead All Lines into a List\nf = open(\"notes.txt\", \"r\")\nlines = f.readlines()\nprint(lines)\nf.close()\n\nf.readlines() returns a list where each element is one line.\n\nIterating Over a File The most common and memory-friendly way:\nf = open(\"notes.txt\", \"r\")\nfor line in f:\n    print(line.strip())\nf.close()\n\nThis reads one line at a time, great for large files.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nMethod\nWhat it Does\nExample\n\n\n\n\nf.read()\nReads whole file as a string\ncontent = f.read()\n\n\nf.readline()\nReads the next line\nline = f.readline()\n\n\nf.readlines()\nReads all lines into a list\nlines = f.readlines()\n\n\nfor line in f\nIterates line by line (efficient)\nfor l in f: print(l)\n\n\n\n\n\nTiny Code\nwith open(\"notes.txt\", \"r\") as f:\n    for line in f:\n        print(\"Line:\", line.strip())\n\n\nWhy it Matters\nReading files is fundamental to processing data. Whether you’re analyzing logs, reading configurations, or loading datasets, understanding the different read methods helps you handle small and large files efficiently.\n\n\nTry It Yourself\n\nWrite three lines into data.txt.\nRead the entire file at once with f.read().\nUse f.readline() twice to print the first two lines separately.\nUse a loop to print each line from the file without extra spaces.\n\n\n\n\n53. Writing Files\nPython lets you write text to files using the write() and writelines() methods. This is useful for saving logs, results, or any output that needs to be stored permanently.\n\nDeep Dive\nWrite Text with write() Opening a file in \"w\" mode will overwrite it if it already exists, or create it if it doesn’t.\nf = open(\"output.txt\", \"w\")\nf.write(\"Hello, world!\\n\")\nf.write(\"This is a new line.\\n\")\nf.close()\nAppend Mode (\"a\") To keep existing content and add to the end:\nf = open(\"output.txt\", \"a\")\nf.write(\"Adding more text here.\\n\")\nf.close()\nWrite Multiple Lines with writelines()\nlines = [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\n\nf = open(\"multi.txt\", \"w\")\nf.writelines(lines)\nf.close()\n⚠️ Note: writelines() does not add newlines automatically—you must include \\n yourself.\nBest Practice with with Automatically closes the file after writing:\nwith open(\"log.txt\", \"w\") as f:\n    f.write(\"Log entry 1\\n\")\n    f.write(\"Log entry 2\\n\")\nQuick Summary Table\n\n\n\nMode\nBehavior\nExample\n\n\n\n\n\"w\"\nWrite (overwrite existing file)\nopen(\"f.txt\", \"w\")\n\n\n\"a\"\nAppend (keep existing, add more)\nopen(\"f.txt\", \"a\")\n\n\n\"x\"\nCreate (error if file exists)\nopen(\"f.txt\", \"x\")\n\n\n\n\n\nTiny Code\nwith open(\"diary.txt\", \"w\") as f:\n    f.write(\"Day 1: Learned Python file writing.\\n\")\n    f.write(\"Day 2: Feeling confident!\\n\")\n\n\nWhy it Matters\nBeing able to write files is crucial for persisting data beyond program execution. Logs, reports, exported data, and notes all rely on writing to files.\n\n\nTry It Yourself\n\nCreate a file journal.txt and write three lines about your day.\nOpen the file again in \"a\" mode and add two more lines.\nUse writelines() to add a list of tasks into tasks.txt.\nReopen and read back the contents to confirm everything was saved.\n\n\n\n\n54. File Modes (r, w, a, b)\nWhen opening files in Python with open(), the mode determines how the file is accessed—read, write, append, or binary. Understanding modes is essential to avoid overwriting or corrupting files.\n\nDeep Dive\nText Modes (default)\n\n\"r\" → Read (default). File must exist.\n\"w\" → Write. Creates new file or overwrites existing.\n\"a\" → Append. Adds to the end, keeps existing content.\n\"x\" → Create. Errors if the file already exists.\n\nopen(\"notes.txt\", \"r\")  # read\nopen(\"notes.txt\", \"w\")  # write (erase contents!)\nopen(\"notes.txt\", \"a\")  # append\nopen(\"newfile.txt\", \"x\")# create only if not exists\nBinary Modes Add \"b\" to handle non-text files (images, audio, executables).\n\n\"rb\" → read binary.\n\"wb\" → write binary.\n\"ab\" → append binary.\n\n# Reading an image\nwith open(\"photo.jpg\", \"rb\") as f:\n    data = f.read()\n\n# Writing binary\nwith open(\"copy.jpg\", \"wb\") as f:\n    f.write(data)\nCombining Modes You can mix read/write with \"+\":\n\n\"r+\" → read & write (file must exist).\n\"w+\" → write & read (overwrites or creates).\n\"a+\" → append & read.\n\nwith open(\"data.txt\", \"r+\") as f:\n    content = f.read()\n    f.write(\"\\nExtra line\")\nQuick Summary Table\n\n\n\nMode\nDescription\nNotes\n\n\n\n\n\"r\"\nRead (default)\nFile must exist\n\n\n\"w\"\nWrite\nOverwrites file\n\n\n\"a\"\nAppend\nAdds at end of file\n\n\n\"x\"\nCreate new\nError if file exists\n\n\n\"b\"\nBinary\nAdd to handle non-text data\n\n\n\"r+\"\nRead + Write\nNo overwrite, must exist\n\n\n\"w+\"\nWrite + Read\nOverwrites existing file\n\n\n\"a+\"\nAppend + Read\nFile pointer at end\n\n\n\n\n\nTiny Code\n# Write + read\nwith open(\"sample.txt\", \"w+\") as f:\n    f.write(\"Hello!\\n\")\n    f.seek(0)\n    print(f.read())\n\n\nWhy it Matters\nChoosing the right mode ensures you don’t lose data accidentally (like \"w\" erasing files) and allows you to correctly handle binary files like images or PDFs.\n\n\nTry It Yourself\n\nOpen a file in \"w\" mode and write two lines. Reopen it in \"r\" mode and confirm old content was overwritten.\nOpen the same file in \"a\" mode and add another line.\nTry using \"x\" mode to create a new file. Run it twice and observe the error on the second run.\nCopy an image using \"rb\" and \"wb\".\n\n\n\n\n55. Closing Files\nWhen you open a file in Python, the system allocates resources to manage it. To free these resources and ensure all data is written properly, you must close the file once you’re done.\n\nDeep Dive\nManual Closing with close()\nf = open(\"notes.txt\", \"w\")\nf.write(\"Hello, file!\")\nf.close()\n\nclose() ensures data is flushed from memory to disk.\nIf you forget, data may not be saved properly.\n\nChecking if a File is Closed\nf = open(\"notes.txt\", \"r\")\nprint(f.closed)   # False\nf.close()\nprint(f.closed)   # True\nBest Practice: with Statement Instead of manually calling close(), use with. It automatically closes the file, even if an error occurs.\nwith open(\"notes.txt\", \"r\") as f:\n    content = f.read()\nprint(f.closed)   # True\nFlushing Without Closing If you want to save changes but keep the file open:\nf = open(\"data.txt\", \"w\")\nf.write(\"Line 1\\n\")\nf.flush()     # forces write to disk\n# file still open\nf.close()\nWhat Happens if You Don’t Close?\n\nData might not be saved (especially in write mode).\nToo many open files can exhaust system resources.\nOn some systems, files stay locked until closed.\n\nQuick Summary Table\n\n\n\nMethod\nBehavior\n\n\n\n\nf.close()\nManually closes the file\n\n\nf.closed\nCheck if file is closed\n\n\nf.flush()\nForce save data without closing\n\n\nwith open()\nAutomatically closes after block\n\n\n\n\n\nTiny Code\nwith open(\"log.txt\", \"w\") as f:\n    f.write(\"Session started.\\n\")\n\nprint(\"Closed?\", f.closed)  # True\n\n\nWhy it Matters\nClosing files ensures data safety and efficient resource usage. Forgetting to close files can lead to bugs, data loss, or locked files. The with statement makes it almost impossible to forget.\n\n\nTry It Yourself\n\nOpen a file in write mode, write some text, and check f.closed before and after calling close().\nUse with open() to write two lines and verify that the file is closed outside the block.\nExperiment with f.flush()—write text, flush, then write more before closing.\nTry opening many files in a loop without closing them, then observe system warnings/errors.\n\n\n\n\n56. Using with Context Manager\nThe with statement in Python provides a clean and safe way to work with files. It automatically takes care of opening and closing the file, even if errors occur while processing.\n\nDeep Dive\nBasic Usage\nwith open(\"notes.txt\", \"r\") as f:\n    content = f.read()\nprint(\"File closed?\", f.closed)  # True\n\nThe file is automatically closed after the with block.\nYou don’t need to call f.close() manually.\n\nWriting with with\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"Hello, Python!\\n\")\n    f.write(\"Writing with context manager.\\n\")\nThe file is saved and closed as soon as the block ends.\nWhy Use with?\n\nEnsures proper cleanup (file is closed automatically).\nHandles exceptions safely.\nMakes code cleaner and shorter.\n\nMultiple Files with One with You can work with multiple files in a single with statement:\nwith open(\"input.txt\", \"r\") as infile, open(\"copy.txt\", \"w\") as outfile:\n    for line in infile:\n        outfile.write(line)\nCustom Context Managers The with statement isn’t just for files—it works with anything that supports the context manager protocol (__enter__ and __exit__).\nExample:\nclass MyResource:\n    def __enter__(self):\n        print(\"Resource acquired\")\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        print(\"Resource released\")\n\nwith MyResource():\n    print(\"Using resource\")\nQuick Summary Table\n\n\n\nFeature\nExample\n\n\n\n\nAuto-close file\nwith open(\"f.txt\") as f:\n\n\nWrite file\nwith open(\"f.txt\",\"w\") as f: f.write(\"x\")\n\n\nMultiple files\nwith open(\"a.txt\") as a, open(\"b.txt\") as b:\n\n\nCustom manager\nDefine __enter__, __exit__\n\n\n\n\n\nTiny Code\nwith open(\"data.txt\", \"w\") as f:\n    f.write(\"Line 1\\n\")\n    f.write(\"Line 2\\n\")\n\nprint(\"Closed?\", f.closed)  # True\n\n\nWhy it Matters\nThe with statement is the best practice for file handling in Python. It makes code safer, shorter, and more reliable by guaranteeing cleanup.\n\n\nTry It Yourself\n\nUse with open(\"log.txt\", \"w\") to write three lines. Confirm the file is closed afterwards.\nCopy the contents of one file into another using a with block.\nExperiment by raising an error inside a with block—notice the file is still closed.\nCreate a simple class with __enter__ and __exit__ to practice writing your own context manager.\n\n\n\n\n57. Working with CSV Files\nCSV (Comma-Separated Values) files are widely used for storing tabular data like spreadsheets or databases. Python’s built-in csv module makes it easy to read and write CSV files.\n\nDeep Dive\nReading a CSV File\nimport csv\n\nwith open(\"data.csv\", \"r\") as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)\n\ncsv.reader → reads file line by line, splitting values by commas.\nEach row is returned as a list of strings.\n\nWriting to a CSV File\nimport csv\n\nrows = [\n    [\"Name\", \"Age\"],\n    [\"Alice\", 25],\n    [\"Bob\", 30]\n]\n\nwith open(\"people.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerows(rows)\n\nwriterow() → writes a single row.\nwriterows() → writes multiple rows.\nnewline=\"\" avoids blank lines on Windows.\n\nUsing Dictionaries with CSV Instead of working with lists, you can use DictReader and DictWriter.\nimport csv\n\n# Writing\nwith open(\"people.csv\", \"w\", newline=\"\") as f:\n    fieldnames = [\"Name\", \"Age\"]\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writeheader()\n    writer.writerow({\"Name\": \"Charlie\", \"Age\": 35})\n\n# Reading\nwith open(\"people.csv\", \"r\") as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(row[\"Name\"], row[\"Age\"])\nQuick Summary Table\n\n\n\nClass/Function\nPurpose\n\n\n\n\ncsv.reader\nReads CSV into lists\n\n\ncsv.writer\nWrites CSV from lists\n\n\ncsv.DictReader\nReads CSV into dictionaries\n\n\ncsv.DictWriter\nWrites CSV from dictionaries\n\n\n\n\n\nTiny Code\nimport csv\n\nwith open(\"scores.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerow([\"Name\", \"Score\"])\n    writer.writerow([\"Alice\", 90])\n    writer.writerow([\"Bob\", 85])\n\nwith open(\"scores.csv\", \"r\") as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)\n\n\nWhy it Matters\nCSV is the most common format for sharing data between systems. By mastering the csv module, you can process spreadsheets, export reports, and integrate with databases or analytics tools.\n\n\nTry It Yourself\n\nCreate a file students.csv with three rows (Name, Age).\nWrite Python code to read and print all rows.\nUse DictWriter to add a new student to the file.\nUse DictReader to print only the Name column.\n\n\n\n\n58. Working with JSON Files\nJSON (JavaScript Object Notation) is a lightweight data format often used for APIs, configs, and data exchange. Python has a built-in json module that makes it easy to read and write JSON files.\n\nDeep Dive\nImporting the Module\nimport json\nWriting JSON to a File\nimport json\n\ndata = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"languages\": [\"Python\", \"JavaScript\"]\n}\n\nwith open(\"data.json\", \"w\") as f:\n    json.dump(data, f)\n\njson.dump(obj, file) → saves Python object as JSON.\nAutomatically converts dicts, lists, strings, numbers, booleans.\n\nReading JSON from a File\nwith open(\"data.json\", \"r\") as f:\n    loaded = json.load(f)\n\nprint(loaded[\"name\"])   # Alice\nprint(loaded[\"languages\"])  # ['Python', 'JavaScript']\nConvert Between JSON and String\n\njson.dumps(obj) → convert Python object → JSON string.\njson.loads(str) → convert JSON string → Python object.\n\ns = json.dumps(data)\nprint(s)   # '{\"name\": \"Alice\", \"age\": 25, ...}'\n\nobj = json.loads(s)\nprint(obj[\"age\"])   # 25\nPretty Printing JSON\nprint(json.dumps(data, indent=4))\nQuick Summary Table\n\n\n\nFunction\nPurpose\n\n\n\n\njson.dump(obj,f)\nWrite JSON to a file\n\n\njson.load(f)\nRead JSON from a file\n\n\njson.dumps(obj)\nConvert object to JSON string\n\n\njson.loads(str)\nConvert JSON string to Python object\n\n\n\n\n\nTiny Code\nimport json\n\nuser = {\"id\": 1, \"active\": True, \"roles\": [\"admin\", \"editor\"]}\n\nwith open(\"user.json\", \"w\") as f:\n    json.dump(user, f, indent=2)\n\nwith open(\"user.json\", \"r\") as f:\n    print(json.load(f))\n\n\nWhy it Matters\nJSON is the universal format for modern applications—from web APIs to configuration files. By mastering Python’s json module, you can easily communicate with APIs, save structured data, and exchange information with other systems.\n\n\nTry It Yourself\n\nCreate a dictionary with your name, age, and hobbies, then save it to me.json.\nReopen me.json and print the hobbies.\nUse json.dumps() to print the same dictionary as a formatted JSON string.\nConvert a JSON string back into a Python dictionary using json.loads().\n\n\n\n\n59. File Exceptions\nWhen working with files, many things can go wrong: the file might not exist, permissions might be missing, or the disk might be full. Python uses exceptions to handle these errors safely.\n\nDeep Dive\nCommon File Exceptions\n\nFileNotFoundError → trying to open a non-existent file.\nPermissionError → trying to open/write without permission.\nIsADirectoryError → opening a directory instead of a file.\nIOError / OSError → general input/output errors (disk, encoding).\n\nHandling File Exceptions\ntry:\n    f = open(\"missing.txt\", \"r\")\n    content = f.read()\n    f.close()\nexcept FileNotFoundError:\n    print(\"The file does not exist.\")\nCatching Multiple Exceptions\ntry:\n    f = open(\"/protected/data.txt\", \"r\")\nexcept (FileNotFoundError, PermissionError) as e:\n    print(\"Error:\", e)\nUsing finally for Cleanup\ntry:\n    f = open(\"data.txt\", \"r\")\n    print(f.read())\nfinally:\n    f.close()   # ensures file closes even on error\nSafer with with The with statement avoids many of these issues automatically, but exceptions can still happen when opening:\ntry:\n    with open(\"notes.txt\", \"r\") as f:\n        print(f.read())\nexcept FileNotFoundError:\n    print(\"File not found!\")\nQuick Summary Table\n\n\n\nException\nCause\n\n\n\n\nFileNotFoundError\nFile does not exist\n\n\nPermissionError\nNo permission to access file\n\n\nIsADirectoryError\nTried to open a directory as a file\n\n\nIOError / OSError\nGeneral input/output failure\n\n\n\n\n\nTiny Code\nfilename = \"example.txt\"\n\ntry:\n    with open(filename, \"r\") as f:\n        print(f.read())\nexcept FileNotFoundError:\n    print(f\"Error: {filename} was not found.\")\n\n\nWhy it Matters\nErrors in file handling are inevitable. Exception handling makes your programs robust, user-friendly, and prevents crashes when dealing with unpredictable files and systems.\n\n\nTry It Yourself\n\nTry opening a file that doesn’t exist, catch the FileNotFoundError, and print a custom message.\nWrite code that catches both FileNotFoundError and PermissionError.\nUse finally to always print \"Done\" after attempting to open a file.\nCombine with open() and try...except to safely read a file only if it exists.\n\n\n\n\n60. Paths & Directories (os, pathlib)\nWorking with files often means dealing with paths and directories. Python provides two main tools for this: the older os module and the modern pathlib module.\n\nDeep Dive\nGetting Current Working Directory\nimport os\nprint(os.getcwd())   # shows current directory\nWith pathlib:\nfrom pathlib import Path\nprint(Path.cwd())\nChanging Directory\nos.chdir(\"/tmp\")\nListing Files in a Directory\nprint(os.listdir(\".\"))   # list all files/folders\nWith pathlib:\np = Path(\".\")\nfor file in p.iterdir():\n    print(file)\nJoining Paths Instead of manually adding slashes, use:\nos.path.join(\"folder\", \"file.txt\")   # \"folder/file.txt\"\nWith pathlib:\nPath(\"folder\") / \"file.txt\"\nChecking File/Folder Existence\nos.path.exists(\"notes.txt\")   # True/False\nWith pathlib:\np = Path(\"notes.txt\")\nprint(p.exists())\nprint(p.is_file())\nprint(p.is_dir())\nCreating Directories\nos.mkdir(\"newfolder\")\nWith parents:\nPath(\"a/b/c\").mkdir(parents=True, exist_ok=True)\nRemoving Files and Folders\nos.remove(\"file.txt\")      # delete file\nos.rmdir(\"empty_folder\")   # remove empty folder\nWith pathlib:\nPath(\"file.txt\").unlink()\nQuick Summary Table\n\n\n\nAction\nos Example\npathlib Example\n\n\n\n\nCurrent dir\nos.getcwd()\nPath.cwd()\n\n\nList dir\nos.listdir(\".\")\nPath(\".\").iterdir()\n\n\nJoin paths\nos.path.join(\"a\",\"b\")\nPath(\"a\") / \"b\"\n\n\nExists?\nos.path.exists(\"f.txt\")\nPath(\"f.txt\").exists()\n\n\nMake dir\nos.mkdir(\"new\")\nPath(\"new\").mkdir()\n\n\nRemove file\nos.remove(\"f.txt\")\nPath(\"f.txt\").unlink()\n\n\n\n\n\nTiny Code\nfrom pathlib import Path\n\np = Path(\"demo_folder\")\np.mkdir(exist_ok=True)\n\nfile = p / \"hello.txt\"\nfile.write_text(\"Hello, pathlib!\")\n\nprint(file.read_text())\n\n\nWhy it Matters\nPaths and directories are essential for any project involving files. pathlib provides a modern, object-oriented approach, while os ensures backward compatibility with older code. Knowing both makes you flexible.\n\n\nTry It Yourself\n\nPrint your current working directory with both os and pathlib.\nCreate a folder called projects and inside it, a file readme.txt with some text.\nList all files inside projects.\nWrite a script that checks if archive/ exists, and if not, creates it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-7.-object-oriented-python",
    "href": "index.html#chapter-7.-object-oriented-python",
    "title": "The Little Book of Python",
    "section": "Chapter 7. Object-Oriented Python",
    "text": "Chapter 7. Object-Oriented Python\n\n61. Classes & Objects\nPython is an object-oriented programming (OOP) language. A class is like a blueprint for creating objects, and an object is an instance of that class. Classes define the structure (attributes) and behavior (methods) of objects.\n\nDeep Dive\nDefining a Class\nclass Person:\n    pass\nThis defines a new class called Person.\nCreating an Object (Instance)\np1 = Person()\nprint(type(p1))   # &lt;class '__main__.Person'&gt;\nHere, p1 is an object of type Person.\nAdding Attributes\nclass Person:\n    def __init__(self, name, age):\n        self.name = name    # attribute\n        self.age = age\n\np1 = Person(\"Alice\", 25)\nprint(p1.name, p1.age)   # Alice 25\n\n__init__ → constructor method, runs when creating an object.\nself → refers to the current object.\n\nAdding Methods\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        return f\"Hello, my name is {self.name}.\"\n\np1 = Person(\"Bob\")\nprint(p1.greet())   # Hello, my name is Bob.\nA method is just a function inside a class that operates on its objects.\nQuick Summary Table\n\n\n\n\n\n\n\n\nConcept\nDefinition\nExample\n\n\n\n\nClass\nBlueprint for objects\nclass Car: ...\n\n\nObject\nInstance of a class\nc1 = Car()\n\n\nAttributes\nData stored in objects\nself.name, self.age\n\n\nMethods\nFunctions inside a class\ndef drive(self): ...\n\n\n__init__\nConstructor, called when object is created\ndef __init__(...)\n\n\nself\nRefers to the current instance\nself.name = name\n\n\n\n\n\nTiny Code\nclass Dog:\n    def __init__(self, name, breed):\n        self.name = name\n        self.breed = breed\n    \n    def bark(self):\n        return f\"{self.name} says Woof!\"\n\nd1 = Dog(\"Max\", \"Labrador\")\nprint(d1.bark())\n\n\nWhy it Matters\nClasses and objects are the foundation of OOP. They let you model real-world things (like cars, users, or bank accounts) in code, organize functionality, and build scalable applications.\n\n\nTry It Yourself\n\nCreate a Car class with attributes brand and year.\nAdd a method drive() that prints \"The car is driving\".\nMake two different Car objects and call their drive() method.\nAdd another method that prints the car’s brand and year.\n\n\n\n\n62. Attributes & Methods\nIn Python classes, attributes are variables that belong to objects, and methods are functions that belong to objects. Together, they define what an object has (data) and what it does (behavior).\n\nDeep Dive\nAttributes (Object Data) Attributes store information about an object.\nclass Car:\n    def __init__(self, brand, year):\n        self.brand = brand\n        self.year = year\n\nc1 = Car(\"Toyota\", 2020)\nprint(c1.brand)   # Toyota\nprint(c1.year)    # 2020\nHere, brand and year are attributes of the Car object.\nInstance Methods (Object Behavior) Methods define actions an object can perform.\nclass Car:\n    def __init__(self, brand, year):\n        self.brand = brand\n        self.year = year\n    \n    def drive(self):\n        return f\"{self.brand} is driving.\"\n\nc1 = Car(\"Honda\", 2019)\nprint(c1.drive())   # Honda is driving.\n\nself allows the method to access the object’s attributes.\n\nUpdating Attributes Attributes can be changed dynamically:\nc1.year = 2022\nprint(c1.year)   # 2022\nAdding New Attributes at Runtime\nc1.color = \"red\"\nprint(c1.color)   # red\n(But it’s better to define attributes in __init__ for consistency.)\nClass Attributes vs Instance Attributes\n\nInstance attribute → unique to each object.\nClass attribute → shared by all objects of the class.\n\nclass Dog:\n    species = \"Canis lupus familiaris\"   # class attribute\n    def __init__(self, name):\n        self.name = name                 # instance attribute\n\nd1 = Dog(\"Buddy\")\nd2 = Dog(\"Charlie\")\nprint(d1.species, d2.species)   # same for all\nprint(d1.name, d2.name)         # unique per dog\nQuick Summary Table\n\n\n\n\n\n\n\n\nTerm\nMeaning\nExample\n\n\n\n\nInstance attribute\nData unique to each object\nself.brand, self.year\n\n\nClass attribute\nShared across all objects\nspecies = ...\n\n\nMethod\nFunction inside a class\ndef drive(self)\n\n\nself\nRefers to the current object instance\nself.name = name\n\n\n\n\n\nTiny Code\nclass Student:\n    school = \"Python Academy\"   # class attribute\n    \n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade      # instance attribute\n    \n    def introduce(self):\n        return f\"I am {self.name}, grade {self.grade}.\"\n\ns1 = Student(\"Alice\", \"A\")\ns2 = Student(\"Bob\", \"B\")\n\nprint(s1.introduce())\nprint(s2.introduce())\nprint(\"School:\", s1.school)\n\n\nWhy it Matters\nAttributes and methods are the building blocks of object-oriented programming. Attributes give objects state, while methods give them behavior. Together, they let you model real-world entities in code.\n\n\nTry It Yourself\n\nDefine a Book class with attributes title and author.\nAdd a method describe() that prints \"Title by Author\".\nCreate two Book objects with different details and call describe() on both.\nAdd a class attribute library = \"City Library\" and print it from both objects.\n\n\n\n\n63. __init__ Constructor\nIn Python, the __init__ method is a special method that runs automatically when you create a new object. It’s often called the constructor because it initializes (sets up) the object’s attributes.\n\nDeep Dive\nBasic Example\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\np1 = Person(\"Alice\", 25)\nprint(p1.name, p1.age)   # Alice 25\n\n__init__ is called right after an object is created.\nself refers to the new object being initialized.\n\nDefault Values You can give parameters default values:\nclass Person:\n    def __init__(self, name=\"Unknown\", age=0):\n        self.name = name\n        self.age = age\n\np1 = Person()\nprint(p1.name, p1.age)   # Unknown 0\nConstructor with Logic You can add checks or calculations during initialization:\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.area = width * height   # auto-calculate\n\nr = Rectangle(4, 5)\nprint(r.area)   # 20\nMultiple Objects, Independent Attributes Each object gets its own copy of instance attributes:\np1 = Person(\"Alice\", 25)\np2 = Person(\"Bob\", 30)\n\nprint(p1.name)   # Alice\nprint(p2.name)   # Bob\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nDefine init\ndef __init__(self, ...):\nRuns on object creation\n\n\nAssign values\nself.attr = value\nStores attributes in object\n\n\nDefaults\ndef __init__(self, x=0)\nOptional parameters\n\n\nWith logic\nCompute or validate values\nSetup object cleanly\n\n\n\n\n\nTiny Code\nclass Dog:\n    def __init__(self, name, breed=\"Unknown\"):\n        self.name = name\n        self.breed = breed\n\nd1 = Dog(\"Max\", \"Beagle\")\nd2 = Dog(\"Charlie\")\n\nprint(d1.name, d1.breed)\nprint(d2.name, d2.breed)\n\n\nWhy it Matters\nThe __init__ constructor ensures every object starts in a well-defined state. Without it, you’d have to manually assign attributes after creating objects, which is error-prone and messy.\n\n\nTry It Yourself\n\nCreate a Car class with attributes brand, model, and year set in __init__.\nAdd a method info() that prints \"Brand Model (Year)\".\nGive year a default value if not provided.\nCreate two Car objects—one with all values, one with just brand and model—and call info() on both.\n\n\n\n\n64. Instance vs Class Variables\nIn Python classes, variables can belong either to a specific object (instance variables) or to the class itself (class variables). Knowing the difference is key to writing predictable, reusable code.\n\nDeep Dive\nInstance Variables\n\nDefined inside __init__ using self.\nEach object gets its own copy.\n\nclass Dog:\n    def __init__(self, name):\n        self.name = name    # instance variable\n\nd1 = Dog(\"Buddy\")\nd2 = Dog(\"Charlie\")\n\nprint(d1.name)   # Buddy\nprint(d2.name)   # Charlie\nEach dog has its own name.\nClass Variables\n\nShared across all objects of the class.\nDefined directly inside the class, outside methods.\n\nclass Dog:\n    species = \"Canis lupus familiaris\"   # class variable\n\n    def __init__(self, name):\n        self.name = name\n\nd1 = Dog(\"Buddy\")\nd2 = Dog(\"Charlie\")\n\nprint(d1.species)   # Canis lupus familiaris\nprint(d2.species)   # Canis lupus familiaris\nChanging it affects all instances:\nDog.species = \"Dog\"\nprint(d1.species, d2.species)  # Dog Dog\nOverriding Class Variables per Instance You can assign a new value to a class variable on a specific object, but then it becomes an instance variable for that object only:\nd1.species = \"Wolf\"   # overrides for d1 only\nprint(d1.species)     # Wolf\nprint(d2.species)     # Dog\nQuick Summary Table\n\n\n\n\n\n\n\n\n\nVariable Type\nDefined Where\nBelongs To\nExample\n\n\n\n\nInstance\nInside __init__ via self\nEach object\nself.name = name\n\n\nClass\nInside class body\nThe class\nspecies = \"Dog\"\n\n\n\n\n\nTiny Code\nclass Student:\n    school = \"Python Academy\"   # class variable\n    \n    def __init__(self, name):\n        self.name = name        # instance variable\n\ns1 = Student(\"Alice\")\ns2 = Student(\"Bob\")\n\nprint(s1.name, \"-\", s1.school)\nprint(s2.name, \"-\", s2.school)\n\nStudent.school = \"Code Academy\"\nprint(s1.school, s2.school)\n\n\nWhy it Matters\n\nUse instance variables for data unique to each object.\nUse class variables for properties shared across all objects. Mixing them up can cause bugs, so it’s important to understand the difference.\n\n\n\nTry It Yourself\n\nCreate a Car class with a class variable wheels = 4.\nAdd an instance variable brand inside __init__.\nMake two cars with different brands, and confirm they both show 4 wheels.\nChange Car.wheels = 6 and check how it affects both objects.\n\n\n\n\n65. Inheritance Basics\nInheritance allows one class to take on the attributes and methods of another. This promotes code reuse and models real-world relationships (e.g., a Dog is an Animal).\n\nDeep Dive\nParent and Child Classes\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return f\"{self.name} makes a sound.\"\n\nclass Dog(Animal):   # Dog inherits from Animal\n    def bark(self):\n        return f\"{self.name} says Woof!\"\na = Animal(\"Generic\")\nprint(a.speak())     # Generic makes a sound.\n\nd = Dog(\"Buddy\")\nprint(d.speak())     # Buddy makes a sound. (inherited)\nprint(d.bark())      # Buddy says Woof! (own method)\nThe super() Function super() lets the child class call methods from the parent class.\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Cat(Animal):\n    def __init__(self, name, color):\n        super().__init__(name)   # call parent constructor\n        self.color = color\nc = Cat(\"Luna\", \"Gray\")\nprint(c.name, c.color)   # Luna Gray\nOverriding Methods A child can redefine methods from the parent:\nclass Animal:\n    def speak(self):\n        return \"Some sound\"\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nprint(Dog().speak())   # Woof!\nInheritance Hierarchy\n\nA class can inherit from another class.\nYou can create chains (e.g., A → B → C).\nPython supports multiple inheritance (covered later).\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nConcept\nMeaning\nExample\n\n\n\n\nParent class\nBase class being inherited from\nclass Animal:\n\n\nChild class\nDerived class that inherits from parent\nclass Dog(Animal):\n\n\nInheritance\nChild gets parent’s attributes/methods\nDog uses speak()\n\n\nsuper()\nCall parent methods inside child\nsuper().__init__(...)\n\n\nOverriding\nRedefining a parent method in the child\ndef speak(self): ...\n\n\n\n\n\nTiny Code\nclass Vehicle:\n    def __init__(self, brand):\n        self.brand = brand\n    def drive(self):\n        return f\"{self.brand} is moving.\"\n\nclass Car(Vehicle):\n    def drive(self):\n        return f\"{self.brand} is driving on the road.\"\n\nv = Vehicle(\"Generic Vehicle\")\nc = Car(\"Toyota\")\n\nprint(v.drive())\nprint(c.drive())\n\n\nWhy it Matters\nInheritance reduces duplication and makes code more organized. By building hierarchies, you can model relationships between classes naturally, reusing and extending existing functionality.\n\n\nTry It Yourself\n\nCreate a base class Shape with a method area() that returns 0.\nMake a child class Circle that overrides area() to compute πr².\nCreate a class Square that overrides area() to compute side².\nUse super().__init__() to pass shared attributes from parent to child.\n\n\n\n\n66. Method Overriding\nMethod overriding happens when a child class defines a method with the same name as one in its parent class. The child’s version replaces (overrides) the parent’s when called on a child object.\n\nDeep Dive\nBasic Example\nclass Animal:\n    def speak(self):\n        return \"Some generic sound\"\n\nclass Dog(Animal):\n    def speak(self):   # overrides parent method\n        return \"Woof!\"\n\na = Animal()\nd = Dog()\n\nprint(a.speak())   # Some generic sound\nprint(d.speak())   # Woof!\nWhy Override?\n\nTo provide specialized behavior in a child class.\nKeeps shared structure in the parent but allows customization.\n\nUsing super() with Overrides You can call the parent’s version inside the override:\nclass Vehicle:\n    def drive(self):\n        return \"The vehicle is moving.\"\n\nclass Car(Vehicle):\n    def drive(self):\n        parent_drive = super().drive()\n        return parent_drive + \" Specifically, the car is driving.\"\n\nc = Car()\nprint(c.drive())\nPartial Overrides You don’t always have to replace the entire method—you can extend it:\nclass Logger:\n    def log(self, message):\n        print(\"Log:\", message)\n\nclass TimestampLogger(Logger):\n    def log(self, message):\n        import datetime\n        time = datetime.datetime.now()\n        super().log(f\"{time} - {message}\")\nQuick Summary Table\n\n\n\n\n\n\n\n\nConcept\nMeaning\nExample\n\n\n\n\nOverriding\nRedefine method in child class\nDog.speak() replaces Animal.speak()\n\n\nSpecialized\nChild provides its own implementation\nCar.drive() different from Vehicle.drive()\n\n\nsuper() use\nCall parent version inside child\nsuper().log(...)\n\n\n\n\n\nTiny Code\nclass Employee:\n    def work(self):\n        return \"Employee is working.\"\n\nclass Manager(Employee):\n    def work(self):\n        return \"Manager is planning and managing.\"\n\ne = Employee()\nm = Manager()\n\nprint(e.work())   # Employee is working.\nprint(m.work())   # Manager is planning and managing.\n\n\nWhy it Matters\nMethod overriding lets subclasses adapt behavior without rewriting everything from scratch. It’s a cornerstone of polymorphism, where different classes can define the same method name but act differently.\n\n\nTry It Yourself\n\nCreate a base class Animal with sound() that returns \"Unknown sound\".\nMake Dog and Cat subclasses that override sound() with \"Woof\" and \"Meow\".\nUse a loop to call sound() on both objects and see polymorphism in action.\nExtend the base method in one subclass using super() to add extra behavior.\n\n\n\n\n67. Multiple Inheritance\nPython allows a class to inherit from more than one parent class. This is called multiple inheritance. It can be powerful but must be used carefully to avoid confusion.\n\nDeep Dive\nBasic Example\nclass Flyer:\n    def fly(self):\n        return \"I can fly!\"\n\nclass Swimmer:\n    def swim(self):\n        return \"I can swim!\"\n\nclass Duck(Flyer, Swimmer):   # inherits from both\n    pass\n\nd = Duck()\nprint(d.fly())   # I can fly!\nprint(d.swim())  # I can swim!\nHere, Duck inherits methods from both Flyer and Swimmer.\nThe Diamond Problem & MRO If multiple parents have methods with the same name, Python uses the Method Resolution Order (MRO) to decide which one to call.\nclass A:\n    def hello(self):\n        return \"Hello from A\"\n\nclass B(A):\n    def hello(self):\n        return \"Hello from B\"\n\nclass C(A):\n    def hello(self):\n        return \"Hello from C\"\n\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.hello())        # Hello from B\nprint(D.mro())          # [D, B, C, A, object]\n\nPython searches left to right in the inheritance list (B before C).\nmro() shows the order.\n\nUsing super() with Multiple Inheritance super() respects the MRO, allowing cooperative behavior:\nclass A:\n    def action(self):\n        print(\"A action\")\n\nclass B(A):\n    def action(self):\n        super().action()\n        print(\"B action\")\n\nclass C(A):\n    def action(self):\n        super().action()\n        print(\"C action\")\n\nclass D(B, C):\n    def action(self):\n        super().action()\n        print(\"D action\")\n\nd = D()\nd.action()\nOutput:\nA action\nC action\nB action\nD action\nQuick Summary Table\n\n\n\nConcept\nMeaning\n\n\n\n\nMultiple inheritance\nClass inherits from more than one parent\n\n\nMRO\nDefines search order for methods/attributes\n\n\nDiamond problem\nAmbiguity when same method exists in parents\n\n\nsuper() in MRO\nEnsures cooperative method calls\n\n\n\n\n\nTiny Code\nclass Writer:\n    def write(self):\n        return \"Writing...\"\n\nclass Reader:\n    def read(self):\n        return \"Reading...\"\n\nclass Author(Writer, Reader):\n    pass\n\na = Author()\nprint(a.write())\nprint(a.read())\n\n\nWhy it Matters\nMultiple inheritance allows you to combine behaviors from different classes, making code flexible and modular. But without understanding MRO, it can introduce bugs and unexpected results.\n\n\nTry It Yourself\n\nCreate two classes Walker and Runner, each with a method.\nCreate a class Athlete that inherits from both and test all methods.\nAdd the same method train() in both parents and see which one Athlete uses.\nUse ClassName.mro() to confirm the method resolution order.\n\n\n\n\n68. Encapsulation & Private Members\nEncapsulation is the principle of restricting direct access to some parts of an object, protecting its internal state. In Python, this is done through naming conventions rather than strict enforcement.\n\nDeep Dive\nPublic Members\n\nAccessible from anywhere.\nDefault in Python.\n\nclass Person:\n    def __init__(self, name):\n        self.name = name   # public attribute\n\np = Person(\"Alice\")\nprint(p.name)   # Alice\nProtected Members (_var)\n\nIndicated with a single underscore.\nTreated as “internal use only”, but still accessible.\n\nclass Person:\n    def __init__(self, name):\n        self._secret = \"hidden\"\n\np = Person(\"Alice\")\nprint(p._secret)   # possible, but discouraged\nPrivate Members (__var)\n\nIndicated with double underscores.\nName-mangled to prevent accidental access.\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.__balance = balance   # private\n\n    def deposit(self, amount):\n        self.__balance += amount\n\n    def get_balance(self):\n        return self.__balance\n\nacc = BankAccount(100)\nacc.deposit(50)\nprint(acc.get_balance())   # 150\nTrying to access directly:\nprint(acc.__balance)   # AttributeError\nprint(acc._BankAccount__balance)   # works (name-mangled)\nWhy Encapsulation?\n\nPrevent accidental modification of sensitive data.\nProvide controlled access via methods (getters/setters).\nSeparate internal logic from public API.\n\nQuick Summary Table\n\n\n\nConvention\nSyntax\nAccess Level\n\n\n\n\nPublic\nvar\nFree to access\n\n\nProtected\n_var\nInternal use only\n\n\nPrivate\n__var\nStrongly restricted (name-mangled)\n\n\n\n\n\nTiny Code\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name            # public\n        self._grade = grade         # protected\n        self.__id = 12345           # private\n    \n    def get_id(self):\n        return self.__id\n\ns = Student(\"Bob\", \"A\")\nprint(s.name)       # Public\nprint(s._grade)     # Accessible but discouraged\nprint(s.get_id())   # Safe access\n\n\nWhy it Matters\nEncapsulation protects the integrity of your objects. By controlling access, you reduce bugs and make your code safer and more maintainable.\n\n\nTry It Yourself\n\nCreate a BankAccount class with a private __balance.\nAdd deposit() and withdraw() methods that safely modify it.\nAdd a method get_balance() to return the balance.\nTry accessing __balance directly and observe the error.\n\n\n\n\n69. Special Methods (__str__, __len__, etc.)\nPython classes can define special methods (also called dunder methods, because they have double underscores). These let objects behave like built-in types and integrate smoothly with Python features.\n\nDeep Dive\n__str__ → String Representation Defines what print(obj) shows.\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __str__(self):\n        return f\"{self.name}, {self.age} years old\"\n\np = Person(\"Alice\", 25)\nprint(p)   # Alice, 25 years old\n__repr__ → Developer-Friendly Representation Used in debugging and interactive shells.\nclass Person:\n    def __repr__(self):\n        return f\"Person(name='{self.name}', age={self.age})\"\n__len__ → Length Lets your object work with len(obj).\nclass Team:\n    def __init__(self, members):\n        self.members = members\n    def __len__(self):\n        return len(self.members)\n\nt = Team([\"Alice\", \"Bob\"])\nprint(len(t))   # 2\n__getitem__ and __setitem__ → Indexing Make objects behave like lists/dicts.\nclass Notebook:\n    def __init__(self):\n        self.notes = {}\n    def __getitem__(self, key):\n        return self.notes[key]\n    def __setitem__(self, key, value):\n        self.notes[key] = value\n\nn = Notebook()\nn[\"day1\"] = \"Learn Python\"\nprint(n[\"day1\"])   # Learn Python\nOther Useful Special Methods\n\n__eq__ → equality (==)\n__lt__ → less than (&lt;)\n__add__ → addition (+)\n__call__ → make object callable like a function\n__iter__ → make object iterable in for loops\n\nQuick Summary Table\n\n\n\nMethod\nPurpose\nExample Use\n\n\n\n\n__str__\nUser-friendly string\nprint(obj)\n\n\n__repr__\nDebug/developer string\nobj in console\n\n\n__len__\nLength\nlen(obj)\n\n\n__getitem__\nIndexing\nobj[key]\n\n\n__setitem__\nAssigning by key\nobj[key] = value\n\n\n__eq__\nEquality check\nobj1 == obj2\n\n\n__add__\nAddition\nobj1 + obj2\n\n\n__call__\nCallable object\nobj()\n\n\n\n\n\nTiny Code\nclass Counter:\n    def __init__(self, count=0):\n        self.count = count\n    \n    def __str__(self):\n        return f\"Counter({self.count})\"\n    \n    def __add__(self, other):\n        return Counter(self.count + other.count)\n\nc1 = Counter(3)\nc2 = Counter(7)\nprint(c1)           # Counter(3)\nprint(c1 + c2)      # Counter(10)\n\n\nWhy it Matters\nSpecial methods let you design objects that feel natural to use, just like built-in types. This makes your classes more powerful, expressive, and Pythonic.\n\n\nTry It Yourself\n\nCreate a Book class with title and author, and override __str__ to print \"Title by Author\".\nAdd __len__ to return the length of the title.\nImplement __eq__ to compare two books by title and author.\nImplement __add__ so that adding two books returns a string joining both titles.\n\n\n\n\n70. Static & Class Methods\nIn Python, not all methods need to work with a specific object. Sometimes they belong to the class itself. Python provides class methods and static methods for these cases.\n\nDeep Dive\nInstance Method (Default)\n\nThe usual method, works with an instance.\nFirst parameter is always self.\n\nclass Person:\n    def greet(self):\n        return \"Hello!\"\nClass Method (@classmethod)\n\nWorks with the class, not an individual object.\nFirst parameter is cls (the class).\nDeclared with @classmethod decorator.\n\nclass Person:\n    species = \"Homo sapiens\"\n\n    @classmethod\n    def get_species(cls):\n        return cls.species\n\nprint(Person.get_species())  # Homo sapiens\nStatic Method (@staticmethod)\n\nDoes not use self or cls.\nA regular function inside a class for logical grouping.\nDeclared with @staticmethod.\n\nclass MathUtils:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\nprint(MathUtils.add(5, 7))   # 12\nWhen to Use What\n\nInstance method → operates on object data.\nClass method → operates on class-level data.\nStatic method → utility function logically related to the class.\n\nQuick Summary Table\n\n\n\nType\nFirst Arg\nAccesses\nUse Case\n\n\n\n\nInstance Method\nself\nObject\nWork with object attributes\n\n\nClass Method\ncls\nClass\nWork with class attributes\n\n\nStatic Method\nNone\nNothing\nUtility/helper function\n\n\n\n\n\nTiny Code\nclass Temperature:\n    def __init__(self, celsius):\n        self.celsius = celsius\n\n    @classmethod\n    def from_fahrenheit(cls, f):\n        return cls((f - 32) * 5/9)\n\n    @staticmethod\n    def is_freezing(temp_c):\n        return temp_c &lt;= 0\n\nt = Temperature.from_fahrenheit(32)\nprint(t.celsius)                  # 0.0\nprint(Temperature.is_freezing(-5)) # True\n\n\nWhy it Matters\nStatic and class methods give you more flexibility in structuring code. They help keep related functions together inside classes, even if they don’t act on specific objects.\n\n\nTry It Yourself\n\nCreate a Circle class with a class variable pi = 3.14. Add a @classmethod get_pi() that returns it.\nAdd a @staticmethod area(radius) that computes circle area using pi.\nCreate a circle and check both methods.\nTry calling them on both the class and an instance.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-8.-error-handling-and-exceptions",
    "href": "index.html#chapter-8.-error-handling-and-exceptions",
    "title": "The Little Book of Python",
    "section": "Chapter 8. Error Handling and Exceptions",
    "text": "Chapter 8. Error Handling and Exceptions\n\n71. What Are Exceptions?\nAn exception is an error that happens during program execution, interrupting the normal flow. Unlike syntax errors (which stop code before running), exceptions occur at runtime and can be handled so the program doesn’t crash.\n\nDeep Dive\nCommon Examples of Exceptions\nprint(10 / 0)       # ZeroDivisionError\nnumbers = [1, 2, 3]\nprint(numbers[5])   # IndexError\nint(\"hello\")        # ValueError\nopen(\"nofile.txt\")  # FileNotFoundError\nWithout handling, these errors stop the program immediately.\nPython Exception Hierarchy\n\nAll exceptions inherit from the built-in Exception class.\nExamples:\n\nValueError → invalid type of value.\nTypeError → wrong data type.\nKeyError → missing dictionary key.\nOSError → file system-related errors.\n\n\nDifference Between Errors and Exceptions\n\nError: general term for something wrong (syntax or runtime).\nException: specific type of runtime error that can be caught and handled.\n\nQuick Summary Table\n\n\n\nException Type\nExample Situation\n\n\n\n\nZeroDivisionError\nDividing by zero\n\n\nIndexError\nAccessing list index that doesn’t exist\n\n\nKeyError\nAccessing missing dict key\n\n\nFileNotFoundError\nFile does not exist\n\n\nValueError\nWrong value type\n\n\nTypeError\nWrong operation on data type\n\n\n\n\n\nTiny Code\ntry:\n    num = int(\"abc\")   # invalid conversion\nexcept ValueError:\n    print(\"Oops! That was not a valid number.\")\n\n\nWhy it Matters\nExceptions are unavoidable in real-world programs. By understanding them, you can write code that fails gracefully instead of crashing unexpectedly.\n\n\nTry It Yourself\n\nTry dividing a number by zero and observe the exception.\nAccess an element outside a list’s range and note the error.\nUse int(\"abc\") and catch the ValueError.\nTry opening a file that doesn’t exist to see a FileNotFoundError.\n\n\n\n\n72. Common Exceptions (ValueError, TypeError, etc.)\nPython has many built-in exceptions that you will encounter often. Knowing them helps you quickly identify problems and handle them gracefully.\n\nDeep Dive\nValueError Occurs when a function gets the right type of input but an inappropriate value.\nint(\"hello\")    # ValueError\nTypeError Occurs when an operation or function is applied to an object of the wrong type.\n\"5\" + 3   # TypeError: cannot add str and int\nIndexError Happens when you try to access an index outside the valid range of a list.\nnums = [1, 2, 3]\nprint(nums[5])   # IndexError\nKeyError Raised when trying to access a dictionary key that doesn’t exist.\nperson = {\"name\": \"Alice\"}\nprint(person[\"age\"])   # KeyError\nFileNotFoundError Occurs when you try to open a file that doesn’t exist.\nopen(\"missing.txt\")   # FileNotFoundError\nZeroDivisionError Raised when dividing a number by zero.\n10 / 0   # ZeroDivisionError\nQuick Summary Table\n\n\n\nException\nExample Trigger\n\n\n\n\nValueError\nint(\"abc\")\n\n\nTypeError\n\"5\" + 3\n\n\nIndexError\n[1,2,3][10]\n\n\nKeyError\n{\"a\":1}[\"b\"]\n\n\nFileNotFoundError\nopen(\"nofile.txt\")\n\n\nZeroDivisionError\n1 / 0\n\n\n\n\n\nTiny Code\ntry:\n    nums = [1, 2, 3]\n    print(nums[10])\nexcept IndexError:\n    print(\"Oops! That index doesn't exist.\")\n\n\nWhy it Matters\nThese exceptions are among the most frequent in Python. Understanding them helps you debug faster and design safer programs by predicting possible errors.\n\n\nTry It Yourself\n\nTrigger a TypeError by adding a string and a number.\nCreate a dictionary and access a non-existent key to raise a KeyError.\nOpen a file that doesn’t exist and catch the FileNotFoundError.\nWrite code that divides by zero and catch the ZeroDivisionError.\n\n\n\n\n73. try and except Blocks\nPython uses try and except to handle exceptions gracefully. Instead of crashing, the program jumps to the except block when an error occurs.\n\nDeep Dive\nBasic Structure\ntry:\n    # code that may cause an error\n    x = int(\"abc\")\nexcept ValueError:\n    print(\"That was not a number!\")\n\nThe code inside try is executed.\nIf an exception occurs, the matching except block runs.\nIf no error happens, the except block is skipped.\n\nCatching Different Exceptions You can handle multiple specific errors separately:\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero.\")\nexcept ValueError:\n    print(\"Invalid value.\")\nCatching Any Exception\ntry:\n    f = open(\"nofile.txt\")\nexcept Exception as e:\n    print(\"Error occurred:\", e)\n⚠️ Be careful—catching all exceptions may hide bugs.\nMultiple Statements in try If one statement fails, control jumps immediately to except, skipping the rest of the try block.\ntry:\n    print(\"Before error\")\n    x = 5 / 0\n    print(\"This won't run\")\nexcept ZeroDivisionError:\n    print(\"Handled division by zero\")\nQuick Summary Table\n\n\n\nKeyword\nPurpose\n\n\n\n\ntry\nWraps code that may cause an error\n\n\nexcept\nDefines how to handle specific exceptions\n\n\nas e\nCaptures the exception object\n\n\n\n\n\nTiny Code\ntry:\n    num = int(\"42a\")\n    print(\"Converted:\", num)\nexcept ValueError as e:\n    print(\"Error:\", e)\n\n\nWhy it Matters\ntry/except is the foundation of error handling in Python. It lets you recover from errors, give helpful messages, and keep your program running.\n\n\nTry It Yourself\n\nWrite code that divides two numbers but catches ZeroDivisionError.\nTry converting a string to int, and catch ValueError.\nOpen a non-existent file and catch FileNotFoundError.\nUse except Exception as e to print the error message.\n\n\n\n\n74. Catching Multiple Exceptions\nSometimes, different types of errors can occur in the same block of code. Python allows you to handle multiple exceptions separately or together.\n\nDeep Dive\nSeparate Except Blocks You can write different handlers for each type of exception:\ntry:\n    x = int(\"abc\")    # may cause ValueError\n    y = 10 / 0        # may cause ZeroDivisionError\nexcept ValueError:\n    print(\"Invalid conversion to int.\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero.\")\nCatching Multiple Exceptions in One Block You can group exceptions in a tuple:\ntry:\n    data = [1, 2, 3]\n    print(data[5])    # IndexError\nexcept (ValueError, IndexError) as e:\n    print(\"Caught an error:\", e)\nGeneric Catch-All The Exception base class catches everything derived from it:\ntry:\n    result = 10 / 0\nexcept Exception as e:\n    print(\"Something went wrong:\", e)\nOrder Matters Python matches the first fitting except.\ntry:\n    10 / 0\nexcept Exception:\n    print(\"General error\")     # this will run\nexcept ZeroDivisionError:\n    print(\"Specific error\")    # never reached\n⚠️ Always put specific exceptions first before generic ones.\nQuick Summary Table\n\n\n\n\n\n\n\n\nStyle\nExample\nUse Case\n\n\n\n\nSeparate handlers\nexcept ValueError: ...\nDifferent handling per exception\n\n\nGrouped in tuple\nexcept (A, B): ...\nSame handling for multiple types\n\n\nGeneral Exception catch-all\nexcept Exception as e:\nDebugging, fallback handling\n\n\n\n\n\nTiny Code\ntry:\n    num = int(\"xyz\")\n    result = 10 / 0\nexcept ValueError:\n    print(\"Conversion failed.\")\nexcept ZeroDivisionError:\n    print(\"Math error: division by zero.\")\n\n\nWhy it Matters\nMost real-world code must guard against different failure modes. Being able to catch multiple exceptions lets you handle each case correctly without stopping the whole program.\n\n\nTry It Yourself\n\nConvert \"abc\" to an integer and catch ValueError.\nDivide by zero in the same block, and handle ZeroDivisionError.\nUse one except (ValueError, ZeroDivisionError) to handle both at once.\nAdd a final generic except Exception as e: to print any unexpected error.\n\n\n\n\n75. else in Exception Handling\nIn Python, you can use an else block with try/except. The else block runs only if no exception was raised in the try block.\n\nDeep Dive\nBasic Structure\ntry:\n    x = int(\"42\")   # no error here\nexcept ValueError:\n    print(\"Conversion failed.\")\nelse:\n    print(\"Conversion successful:\", x)\n\nIf the code in try succeeds, the else block runs.\nIf an exception occurs, the else block is skipped.\n\nWhy Use else?\n\nKeeps your try block focused only on code that might fail.\nPuts the “safe” code in else, separating it clearly.\n\nExample:\ntry:\n    f = open(\"data.txt\")\nexcept FileNotFoundError:\n    print(\"File not found.\")\nelse:\n    print(\"File opened successfully.\")\n    f.close()\nWith Multiple Exceptions\ntry:\n    num = int(\"100\")\nexcept ValueError:\n    print(\"Invalid number.\")\nelse:\n    print(\"Parsed successfully:\", num)\nQuick Summary Table\n\n\n\nBlock\nRuns When\n\n\n\n\ntry\nAlways, until error happens\n\n\nexcept\nIf an error of specified type occurs\n\n\nelse\nIf no errors happened in try\n\n\n\n\n\nTiny Code\ntry:\n    result = 10 / 2\nexcept ZeroDivisionError:\n    print(\"Division failed.\")\nelse:\n    print(\"Division successful:\", result)\n\n\nWhy it Matters\nUsing else makes exception handling cleaner: risky code in try, error handling in except, and safe follow-up code in else. This improves readability and reduces mistakes.\n\n\nTry It Yourself\n\nWrite code that reads a number from a string with int(). If it fails, handle ValueError. If it succeeds, print \"Valid number\" in else.\nTry dividing two numbers, catching ZeroDivisionError, and use else to print the result if successful.\nOpen an existing file in try, handle FileNotFoundError, and confirm success in else.\n\n\n\n\n76. finally Block\nIn Python, the finally block is used with try/except to guarantee that certain code always runs — no matter what happens. This is useful for cleanup tasks like closing files or releasing resources.\n\nDeep Dive\nBasic Structure\ntry:\n    x = 10 / 2\nexcept ZeroDivisionError:\n    print(\"Division failed.\")\nfinally:\n    print(\"This always runs.\")\n\nIf no error: finally still runs.\nIf an error occurs and is caught: finally still runs.\nIf an error occurs and is not caught: finally still runs before the program crashes.\n\nWith else and finally Together\ntry:\n    num = int(\"42\")\nexcept ValueError:\n    print(\"Invalid number\")\nelse:\n    print(\"Conversion successful:\", num)\nfinally:\n    print(\"Execution finished\")\nOrder of execution here:\n\ntry block\nexcept (if error) OR else (if no error)\nfinally (always)\n\nPractical Example: Closing Files\ntry:\n    f = open(\"data.txt\", \"r\")\n    content = f.read()\nexcept FileNotFoundError:\n    print(\"File not found.\")\nfinally:\n    print(\"Closing file...\")\n    try:\n        f.close()\n    except:\n        pass\nQuick Summary Table\n\n\n\nBlock\nRuns When\n\n\n\n\ntry\nAlways, until error happens\n\n\nexcept\nIf an error occurs\n\n\nelse\nIf no error occurs\n\n\nfinally\nAlways, regardless of error or success\n\n\n\n\n\nTiny Code\ntry:\n    print(\"Opening file...\")\n    f = open(\"missing.txt\")\nexcept FileNotFoundError:\n    print(\"Error: File not found.\")\nfinally:\n    print(\"Cleanup done.\")\n\n\nWhy it Matters\nThe finally block ensures important cleanup (like closing files, saving data, disconnecting from databases) always happens — even if the program crashes in the middle.\n\n\nTry It Yourself\n\nWrite code that divides two numbers with try/except, then add a finally block to print \"End of operation\".\nTry opening a file in try, handle FileNotFoundError, and in finally print \"Closing resources\".\nCombine try, except, else, and finally in one program and observe the execution order.\n\n\n\n\n77. Raising Exceptions (raise)\nSometimes, instead of waiting for Python to throw an error, you may want to raise an exception yourself when something unexpected happens. This is done with the raise keyword.\n\nDeep Dive\nBasic Usage\ndef divide(a, b):\n    if b == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero!\")\n    return a / b\n\nprint(divide(10, 2))   # 5.0\nprint(divide(5, 0))    # Raises ZeroDivisionError\nHere, we explicitly raise ZeroDivisionError when dividing by zero.\nRaising Built-in Exceptions You can raise any built-in exception manually:\nage = -1\nif age &lt; 0:\n    raise ValueError(\"Age cannot be negative\")\nRaising Custom Messages Exceptions can carry useful error messages:\nname = \"\"\nif not name:\n    raise Exception(\"Name must not be empty\")\nRe-raising Exceptions Sometimes you catch an error but still want to pass it upward:\ntry:\n    x = int(\"abc\")\nexcept ValueError as e:\n    print(\"Caught an error:\", e)\n    raise   # re-raises the same exception\nQuick Summary Table\n\n\n\n\n\n\n\n\nKeyword\nPurpose\nExample\n\n\n\n\nraise\nManually throw an exception\nraise ValueError(\"Invalid input\")\n\n\nMessage\nProvide details for debugging\nraise Exception(\"Something went wrong\")\n\n\nRe-raise\nPass the error up the stack\nraise inside except\n\n\n\n\n\nTiny Code\ndef check_age(age):\n    if age &lt; 18:\n        raise ValueError(\"Must be at least 18 years old.\")\n    return \"Access granted.\"\n\nprint(check_age(20))   # Access granted\nprint(check_age(15))   # Raises ValueError\n\n\nWhy it Matters\nRaising exceptions gives you control. Instead of letting bad data silently continue, you can stop execution, show a meaningful error, and prevent bigger problems later.\n\n\nTry It Yourself\n\nWrite a withdraw(balance, amount) function. If amount &gt; balance, raise a ValueError.\nCreate a check_name(name) function that raises an exception if the string is empty.\nInside a try/except, catch a ValueError and then re-raise it to see the traceback.\nRaise a custom Exception(\"Custom error message\") and print it.\n\n\n\n\n78. Creating Custom Exceptions\nIn addition to Python’s built-in exceptions, you can define your own custom exceptions to make error handling more meaningful in your programs.\n\nDeep Dive\nDefining a Custom Exception A custom exception is just a class that inherits from Python’s built-in Exception class.\nclass NegativeNumberError(Exception):\n    \"\"\"Raised when a number is negative.\"\"\"\n    pass\nUsing the Custom Exception\ndef square_root(x):\n    if x &lt; 0:\n        raise NegativeNumberError(\"Cannot take square root of negative number\")\n    return x  0.5\n\nprint(square_root(9))   # 3.0\nprint(square_root(-4))  # Raises NegativeNumberError\nAdding Extra Functionality You can extend custom exceptions with attributes.\nclass BalanceError(Exception):\n    def __init__(self, balance, message=\"Insufficient funds\"):\n        self.balance = balance\n        self.message = message\n        super().__init__(f\"{message}. Balance: {balance}\")\n\ndef withdraw(balance, amount):\n    if amount &gt; balance:\n        raise BalanceError(balance)\n    return balance - amount\n\nwithdraw(100, 200)   # Raises BalanceError\nCatching Custom Exceptions\ntry:\n    square_root(-1)\nexcept NegativeNumberError as e:\n    print(\"Custom error caught:\", e)\nWhy Create Custom Exceptions?\n\nMake your errors descriptive and domain-specific.\nEasier debugging since you know exactly what went wrong.\nProvide structured error handling in larger projects.\n\nQuick Summary Table\n\n\n\nStep\nExample\n\n\n\n\nDefine custom error\nclass MyError(Exception): ...\n\n\nRaise it\nraise MyError(\"Something happened\")\n\n\nCatch it\nexcept MyError as e:\n\n\n\n\n\nTiny Code\nclass AgeError(Exception):\n    pass\n\ndef register(age):\n    if age &lt; 18:\n        raise AgeError(\"Must be 18 or older to register\")\n    return \"Registered!\"\n\ntry:\n    print(register(16))\nexcept AgeError as e:\n    print(\"Registration failed:\", e)\n\n\nWhy it Matters\nCustom exceptions make your programs more self-explanatory and professional. Instead of generic errors, you provide meaningful messages tailored to your application’s domain.\n\n\nTry It Yourself\n\nCreate a PasswordError class for invalid passwords.\nWrite a function set_password(pw) that raises PasswordError if the password is less than 8 characters.\nCreate a TemperatureError class and raise it if input temperature is below absolute zero (-273°C).\nCatch your custom exception and print the message.\n\n\n\n\n79. Assertions (assert)\nAn assertion is a quick way to test if a condition in your program is true. If the condition is false, Python raises an AssertionError. Assertions are often used for debugging and catching mistakes early.\n\nDeep Dive\nBasic Usage\nx = 5\nassert x &gt; 0    # passes, nothing happens\nassert x &lt; 0    # fails, raises AssertionError\nWith a Custom Message\nage = -1\nassert age &gt;= 0, \"Age cannot be negative\"\nIf the condition is false, it raises:\nAssertionError: Age cannot be negative\nWhen to Use Assertions\n\nTo check assumptions during development.\nTo catch impossible states in your logic.\nFor debugging, not for handling user errors (use exceptions for that).\n\nTurning Off Assertions\n\nAssertions can be disabled when running Python with the -O (optimize) flag.\nExample: python -O program.py → all assert statements are skipped.\n\nPractical Example\ndef divide(a, b):\n    assert b != 0, \"Denominator must not be zero\"\n    return a / b\n\nprint(divide(10, 2))   # 5.0\nprint(divide(5, 0))    # AssertionError\nQuick Summary Table\n\n\n\nSyntax\nBehavior\n\n\n\n\nassert condition\nRaises AssertionError if condition false\n\n\nassert condition, msg\nRaises with custom message\n\n\nDisabled with -O\nSkips all asserts\n\n\n\n\n\nTiny Code\nscore = 95\nassert 0 &lt;= score &lt;= 100, \"Score must be between 0 and 100\"\nprint(\"Score is valid!\")\n\n\nWhy it Matters\nAssertions help you detect logic errors early. They make your intentions clear in code and act as built-in sanity checks during development.\n\n\nTry It Yourself\n\nWrite an assert to check that a number is positive.\nAdd an assertion in a function to make sure a list isn’t empty before accessing it.\nUse assert to check that temperature is above -273 (absolute zero).\nRun your program with python -O and see that assertions are skipped.\n\n\n\n\n80. Best Practices for Error Handling\nGood error handling makes your programs reliable, readable, and easier to maintain. Instead of letting programs crash or hiding bugs, you should follow certain best practices.\n\nDeep Dive\n\nBe Specific in except Blocks Catch only the exceptions you expect, not all of them.\n\ntry:\n    num = int(\"abc\")\nexcept ValueError:\n    print(\"Invalid number!\")   # good\nAvoid:\nexcept:\n    print(\"Something went wrong\")   # too vague\n\nUse finally for Cleanup Always free resources like files, network connections, or databases.\n\ntry:\n    f = open(\"data.txt\")\n    content = f.read()\nexcept FileNotFoundError:\n    print(\"File not found.\")\nfinally:\n    f.close()\n\nKeep try Blocks Small Put only the risky code inside try, not everything.\n\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Math error\")\nBetter than wrapping the entire function.\n\nDon’t Hide Bugs Catching all exceptions with except Exception should be a last resort. Otherwise, real bugs get hidden.\nRaise Exceptions When Needed Instead of returning special values like -1, raise meaningful errors.\n\ndef withdraw(balance, amount):\n    if amount &gt; balance:\n        raise ValueError(\"Insufficient funds\")\n    return balance - amount\n\nCreate Custom Exceptions for Clarity For domain-specific logic, define your own exceptions (e.g., PasswordTooShortError).\nLog Errors Use Python’s logging module instead of just print().\n\nimport logging\nlogging.error(\"File not found\", exc_info=True)\nQuick Summary Table\n\n\n\nPractice\nWhy It Matters\n\n\n\n\nCatch specific exceptions\nAvoids hiding unrelated bugs\n\n\nUse finally for cleanup\nEnsures resources are freed\n\n\nKeep try small\nImproves readability\n\n\nRaise exceptions\nSignals errors clearly\n\n\nCustom exceptions\nDomain-specific clarity\n\n\nLogging over printing\nProfessional error tracking\n\n\n\n\n\nTiny Code\ndef safe_divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        raise ValueError(\"b must not be zero\")\n\nprint(safe_divide(10, 2))\nprint(safe_divide(5, 0))   # raises ValueError\n\n\nWhy it Matters\nWell-structured error handling prevents small mistakes from becoming big failures. It keeps your programs predictable, professional, and easier to debug.\n\n\nTry It Yourself\n\nWrite a function read_file(filename) that catches FileNotFoundError and raises a new exception with a clearer message.\nAdd a finally block to always print \"Operation complete\".\nTry logging an error instead of printing it.\nRefactor a long try block so it only wraps the risky line of code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-9.-advanced-python-features",
    "href": "index.html#chapter-9.-advanced-python-features",
    "title": "The Little Book of Python",
    "section": "Chapter 9. Advanced Python Features",
    "text": "Chapter 9. Advanced Python Features\n\n81. List Comprehensions\nA list comprehension is a concise way to create lists in Python. It lets you generate new lists by applying an expression to each item in an existing sequence (or iterable), often replacing loops with a single readable line.\n\nDeep Dive\nBasic Syntax\n[expression for item in iterable]\nExample:\nnums = [1, 2, 3, 4]\nsquares = [x2 for x in nums]\nprint(squares)   # [1, 4, 9, 16]\nWith a Condition\nevens = [x for x in range(10) if x % 2 == 0]\nprint(evens)   # [0, 2, 4, 6, 8]\nNested Loops in Comprehensions\npairs = [(x, y) for x in [1, 2] for y in [3, 4]]\nprint(pairs)   # [(1, 3), (1, 4), (2, 3), (2, 4)]\nWith Functions\nwords = [\"hello\", \"python\", \"world\"]\nuppercased = [w.upper() for w in words]\nprint(uppercased)   # ['HELLO', 'PYTHON', 'WORLD']\nReplacing Loops Loop version:\nsquares = []\nfor x in range(5):\n    squares.append(x2)\nComprehension version:\nsquares = [x2 for x in range(5)]\nQuick Summary Table\n\n\n\nForm\nExample\n\n\n\n\nSimple comprehension\n[x*2 for x in range(5)]\n\n\nWith condition\n[x for x in range(10) if x % 2 == 0]\n\n\nNested loops\n[(x,y) for x in [1,2] for y in [3,4]]\n\n\nWith function\n[f(x) for x in items]\n\n\n\n\n\nTiny Code\nnums = [1, 2, 3, 4, 5]\ndouble = [n * 2 for n in nums if n % 2 != 0]\nprint(double)   # [2, 6, 10]\n\n\nWhy it Matters\nList comprehensions make your code shorter, faster, and easier to read. They are a hallmark of Pythonic style, turning loops and conditions into expressive one-liners.\n\n\nTry It Yourself\n\nCreate a list of squares from 1 to 10 using a list comprehension.\nMake a list of only the odd numbers between 1 and 20.\nUse a comprehension to extract the first letter of each word in [\"apple\", \"banana\", \"cherry\"].\nBuild a list of coordinate pairs (x, y) for x in [1,2,3] and y in [4,5].\n\n\n\n\n82. Dictionary Comprehensions\nA dictionary comprehension is a compact way to build dictionaries by combining expressions and loops into a single line. It works like list comprehensions but produces key–value pairs instead of list elements.\n\nDeep Dive\nBasic Syntax\n{key_expression: value_expression for item in iterable}\nExample:\nnums = [1, 2, 3, 4]\nsquares = {x: x2 for x in nums}\nprint(squares)   # {1: 1, 2: 4, 3: 9, 4: 16}\nWith a Condition\neven_squares = {x: x2 for x in range(10) if x % 2 == 0}\nprint(even_squares)   # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\nSwapping Keys and Values\nfruit = {\"a\": \"apple\", \"b\": \"banana\", \"c\": \"cherry\"}\nswap = {v: k for k, v in fruit.items()}\nprint(swap)   # {'apple': 'a', 'banana': 'b', 'cherry': 'c'}\nWith Functions\nwords = [\"hello\", \"world\", \"python\"]\nlengths = {w: len(w) for w in words}\nprint(lengths)   # {'hello': 5, 'world': 5, 'python': 6}\nNested Loops in Dictionary Comprehensions\npairs = {(x, y): x*y for x in [1, 2] for y in [3, 4]}\nprint(pairs)   # {(1, 3): 3, (1, 4): 4, (2, 3): 6, (2, 4): 8}\nQuick Summary Table\n\n\n\nForm\nExample\n\n\n\n\nBasic dict comp\n{x: x*2 for x in range(3)}\n\n\nWith condition\n{x: x2 for x in range(6) if x % 2 == 0}\n\n\nSwap keys and values\n{v: k for k, v in dict.items()}\n\n\nUsing function\n{w: len(w) for w in words}\n\n\nNested loops\n{(x,y): x*y for x in A for y in B}\n\n\n\n\n\nTiny Code\nstudents = [\"Alice\", \"Bob\", \"Charlie\"]\ngrades = {name: \"Pass\" if len(name) &lt;= 4 else \"Review\" for name in students}\nprint(grades)   # {'Alice': 'Review', 'Bob': 'Pass', 'Charlie': 'Review'}\n\n\nWhy it Matters\nDictionary comprehensions save time and reduce boilerplate when building mappings from existing data. They make code cleaner, more expressive, and Pythonic.\n\n\nTry It Yourself\n\nCreate a dictionary mapping numbers 1–5 to their cubes.\nBuild a dictionary of words and their lengths from [\"cat\", \"elephant\", \"dog\"].\nFlip a dictionary {\"x\": 1, \"y\": 2} so values become keys.\nGenerate a dictionary mapping (x, y) pairs to x + y for x in [1,2] and y in [3,4].\n\n\n\n\n83. Set Comprehensions\nA set comprehension is similar to a list comprehension, but it produces a set—an unordered collection of unique elements. It’s a concise way to build sets with loops and conditions.\n\nDeep Dive\nBasic Syntax\n{expression for item in iterable}\nExample:\nnums = [1, 2, 2, 3, 4, 4]\nunique_squares = {x2 for x in nums}\nprint(unique_squares)   # {16, 1, 4, 9}\nWith a Condition\nevens = {x for x in range(10) if x % 2 == 0}\nprint(evens)   # {0, 2, 4, 6, 8}\nFrom a String\nletters = {ch for ch in \"banana\"}\nprint(letters)   # {'a', 'b', 'n'}\nWith Functions\nwords = [\"hello\", \"world\", \"python\"]\nlengths = {len(w) for w in words}\nprint(lengths)   # {5, 6}\nNested Loops in Set Comprehensions\npairs = {(x, y) for x in [1, 2] for y in [3, 4]}\nprint(pairs)   # {(1, 3), (1, 4), (2, 3), (2, 4)}\nQuick Summary Table\n\n\n\nForm\nExample\n\n\n\n\nSimple set comp\n{x*2 for x in range(5)}\n\n\nWith condition\n{x for x in range(10) if x % 2 == 0}\n\n\nFrom string\n{ch for ch in \"banana\"}\n\n\nWith function\n{len(w) for w in words}\n\n\nNested loops\n{(x,y) for x in A for y in B}\n\n\n\n\n\nTiny Code\nnums = [1, 2, 3, 2, 1, 4]\nsquares = {n2 for n in nums if n % 2 != 0}\nprint(squares)   # {1, 9}\n\n\nWhy it Matters\nSet comprehensions provide a quick way to eliminate duplicates and apply transformations at the same time. They’re useful for data cleaning, filtering, and fast membership checks.\n\n\nTry It Yourself\n\nCreate a set of squares from 1–10.\nBuild a set of all vowels in the word \"programming\".\nMake a set of numbers between 1–20 that are divisible by 3.\nGenerate a set of (x, y) pairs where x in [1,2,3] and y in [4,5].\n\n\n\n\n84. Generators (yield)\nA generator is a special type of function that lets you produce a sequence of values lazily, one at a time, using the yield keyword. Unlike regular functions, generators don’t return everything at once—they pause and resume.\n\nDeep Dive\nBasic Generator\ndef count_up_to(n):\n    i = 1\n    while i &lt;= n:\n        yield i\n        i += 1\n\nfor num in count_up_to(5):\n    print(num)\nOutput:\n1\n2\n3\n4\n5\nDifference Between return and yield\n\nreturn → ends the function and gives a single value.\nyield → pauses the function, remembers its state, and continues next time.\n\nUsing Generators with next()\ngen = count_up_to(3)\nprint(next(gen))  # 1\nprint(next(gen))  # 2\nprint(next(gen))  # 3\nInfinite Generators Generators can produce endless sequences:\ndef even_numbers():\n    n = 0\n    while True:\n        yield n\n        n += 2\n\ngen = even_numbers()\nfor _ in range(5):\n    print(next(gen))   # 0 2 4 6 8\nGenerator Expressions Like list comprehensions but with parentheses:\nsquares = (x2 for x in range(5))\nfor s in squares:\n    print(s)\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nBehavior\n\n\n\n\nyield keyword\nyield x\nProduces one value at a time\n\n\nPause & resume\nUses next()\nContinues from last state\n\n\nGenerator function\ndef f(): yield ...\nCreates a generator\n\n\nGenerator expr\n(x2 for x in range(5))\nCompact generator syntax\n\n\n\n\n\nTiny Code\ndef fibonacci(limit):\n    a, b = 0, 1\n    while a &lt;= limit:\n        yield a\n        a, b = b, a + b\n\nfor num in fibonacci(20):\n    print(num)\n\n\nWhy it Matters\nGenerators are memory-efficient because they don’t build the whole list in memory. They’re ideal for large datasets, streams of data, or infinite sequences.\n\n\nTry It Yourself\n\nWrite a generator countdown(n) that yields numbers from n down to 1.\nMake a generator that yields only odd numbers up to 15.\nCreate a generator expression for cubes of numbers 1–5.\nModify the Fibonacci generator to stop after producing 10 numbers.\n\n\n\n\n85. Iterators\nAn iterator is an object that represents a stream of data. It returns items one at a time when you call next() on it, and it remembers its position between calls. Iterators are the foundation of loops, comprehensions, and generators in Python.\n\nDeep Dive\nIterator Protocol An object is an iterator if it implements two methods:\n\n__iter__() → returns the iterator object itself.\n__next__() → returns the next value, or raises StopIteration when done.\n\nBuilt-in Iterators\nnums = [1, 2, 3]\nit = iter(nums)   # get iterator\n\nprint(next(it))   # 1\nprint(next(it))   # 2\nprint(next(it))   # 3\n# next(it) now raises StopIteration\nFor Loops Use Iterators Under the Hood\nfor n in [1, 2, 3]:\n    print(n)\nis equivalent to:\nnums = [1, 2, 3]\nit = iter(nums)\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        break\nCustom Iterator You can build your own iterator by defining __iter__ and __next__:\nclass CountDown:\n    def __init__(self, start):\n        self.current = start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current &lt;= 0:\n            raise StopIteration\n        self.current -= 1\n        return self.current + 1\n\nfor num in CountDown(5):\n    print(num)\nOutput:\n5\n4\n3\n2\n1\nQuick Summary Table\n\n\n\n\n\n\n\n\nConcept\nExample\nPurpose\n\n\n\n\niter(obj)\nit = iter([1,2,3])\nGet iterator from iterable\n\n\nnext(it)\nnext(it)\nGet next value\n\n\nStopIteration\nException when done\nSignals end of iteration\n\n\nCustom\nDefine __iter__, __next__\nCreate your own sequence\n\n\n\n\n\nTiny Code\nnums = [10, 20, 30]\nit = iter(nums)\n\nprint(next(it))  # 10\nprint(next(it))  # 20\nprint(next(it))  # 30\n\n\nWhy it Matters\nUnderstanding iterators explains how loops, generators, and comprehensions actually work in Python. Iterators allow Python to handle large datasets efficiently, consuming one item at a time.\n\n\nTry It Yourself\n\nUse iter() and next() on a string like \"hello\" to get characters one by one.\nBuild a simple custom iterator that counts from 1 to 5.\nWrite a for loop manually using while True and next() with StopIteration.\nCreate a custom iterator EvenNumbers(n) that yields even numbers up to n.\n\n\n\n\n86. Decorators\nA decorator is a special function that takes another function as input, adds extra behavior to it, and returns a new function. In Python, decorators are often used for logging, authentication, caching, and more.\n\nDeep Dive\nBasic Decorator\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function runs\")\n        func()\n        print(\"After function runs\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\nOutput:\nBefore function runs\nHello!\nAfter function runs\n\n@my_decorator is shorthand for say_hello = my_decorator(say_hello).\n\nDecorators with Arguments\ndef repeat(func):\n    def wrapper():\n        for _ in range(3):\n            func()\n    return wrapper\n\n@repeat\ndef greet():\n    print(\"Hi!\")\n\ngreet()\nOutput:\nHi!\nHi!\nHi!\nPassing Arguments to Wrapped Function\ndef log_args(func):\n    def wrapper(*args, kwargs):\n        print(\"Arguments:\", args, kwargs)\n        return func(*args, kwargs)\n    return wrapper\n\n@log_args\ndef add(a, b):\n    return a + b\n\nprint(add(3, 5))\nUsing functools.wraps Without it, the decorated function loses its original name and docstring.\nfrom functools import wraps\n\ndef decorator(func):\n    @wraps(func)\n    def wrapper(*args, kwargs):\n        return func(*args, kwargs)\n    return wrapper\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nBasic decorator\n@my_decorator\nAdd behavior before/after function\n\n\nWith args\ndef wrapper(*args,kwargs)\nWorks with any function signature\n\n\nMultiple decorators\n@d1 + @d2\nStacks behaviors\n\n\nfunctools.wraps\n@wraps(func)\nPreserve metadata\n\n\n\n\n\nTiny Code\ndef uppercase(func):\n    def wrapper():\n        result = func()\n        return result.upper()\n    return wrapper\n\n@uppercase\ndef message():\n    return \"hello world\"\n\nprint(message())   # HELLO WORLD\n\n\nWhy it Matters\nDecorators are a powerful way to separate what a function does from how it’s used. They make code reusable, clean, and Pythonic.\n\n\nTry It Yourself\n\nWrite a decorator @timer that prints how long a function takes to run.\nCreate a decorator @authenticate that prints \"Access denied\" unless a variable user_logged_in = True.\nCombine two decorators on the same function and observe the order of execution.\nUse functools.wraps to keep the function’s original __name__.\n\n\n\n\n87. Context Managers (Custom)\nA context manager is a Python construct that properly manages resources, like opening and closing files. You usually use it with the with statement. While Python has built-in context managers (like open), you can also create your own.\n\nDeep Dive\nUsing with Built-in\nwith open(\"data.txt\", \"r\") as f:\n    content = f.read()\nHere, open is a context manager: it opens the file, then automatically closes it when done.\nCreating a Custom Context Manager with a Class To make your own, define __enter__ and __exit__.\nclass MyResource:\n    def __enter__(self):\n        print(\"Resource acquired\")\n        return self\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        print(\"Resource released\")\n\nwith MyResource() as r:\n    print(\"Using resource\")\nOutput:\nResource acquired\nUsing resource\nResource released\nHandling Errors in __exit__ __exit__ can suppress exceptions if it returns True.\nclass SafeDivide:\n    def __enter__(self):\n        return self\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        return True   # suppress error\n\nwith SafeDivide():\n    print(10 / 0)   # No crash!\nCreating a Context Manager with contextlib\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resource():\n    print(\"Start\")\n    yield\n    print(\"End\")\n\nwith managed_resource():\n    print(\"Inside block\")\nOutput:\nStart\nInside block\nEnd\nQuick Summary Table\n\n\n\n\n\n\n\n\nMethod\nHow it Works\nExample\n\n\n\n\nClass-based\nDefine __enter__ and __exit__\nwith MyClass(): ...\n\n\nFunction-based\nUse @contextmanager decorator\nwith managed_resource(): ...\n\n\nBuilt-in examples\nopen, threading.Lock, sqlite3\nwith open(\"f.txt\") as f:\n\n\n\n\n\nTiny Code\nfrom contextlib import contextmanager\n\n@contextmanager\ndef open_upper(filename):\n    f = open(filename, \"r\")\n    try:\n        yield (line.upper() for line in f)\n    finally:\n        f.close()\n\nwith open_upper(\"data.txt\") as lines:\n    for line in lines:\n        print(line)\n\n\nWhy it Matters\nCustom context managers let you manage setup and cleanup tasks automatically. They make code safer, reduce errors, and ensure resources are always released properly.\n\n\nTry It Yourself\n\nWrite a context manager class that prints \"Start\" when entering and \"End\" when exiting.\nCreate one that temporarily changes the working directory and restores it afterwards.\nUse @contextmanager to make a timer context that prints how long the block took.\nBuild a safe database connection context that opens, yields, then closes automatically.\n\n\n\n\n88. with and Resource Management\nThe with statement in Python is a shortcut for using context managers. It ensures resources (like files, network connections, or locks) are acquired and released properly, even if errors occur.\n\nDeep Dive\nFile Handling with with\nwith open(\"notes.txt\", \"w\") as f:\n    f.write(\"Hello, Python!\")\n\nFile opens automatically.\nFile closes automatically after the block, even if an error happens.\n\nMultiple Resources in One with\nwith open(\"input.txt\", \"r\") as infile, open(\"output.txt\", \"w\") as outfile:\n    for line in infile:\n        outfile.write(line.upper())\nBoth files are managed safely within the same with statement.\nUsing with for Locks (Threading Example)\nimport threading\n\nlock = threading.Lock()\nwith lock:\n    # critical section\n    print(\"Safe access\")\nThe lock is automatically acquired and released.\nDatabase Connections Some libraries provide context managers for connections.\nimport sqlite3\n\nwith sqlite3.connect(\"example.db\") as conn:\n    cursor = conn.cursor()\n    cursor.execute(\"CREATE TABLE IF NOT EXISTS users(id INTEGER)\")\nConnection commits and closes automatically at the end.\nCustom Resource Management Any class with __enter__ and __exit__ can be used in a with block.\nclass Resource:\n    def __enter__(self):\n        print(\"Acquired resource\")\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"Released resource\")\n\nwith Resource():\n    print(\"Using resource\")\nOutput:\nAcquired resource\nUsing resource\nReleased resource\nQuick Summary Table\n\n\n\n\n\n\n\n\nResource Type\nExample with with\nBenefit\n\n\n\n\nFile\nwith open(\"file.txt\") as f:\nAuto-close file\n\n\nThread lock\nwith lock:\nAuto-release lock\n\n\nDatabase connection\nwith sqlite3.connect(...) as conn:\nAuto-commit & close\n\n\nCustom resource\nwith MyResource(): ...\nCustom cleanup\n\n\n\n\n\nTiny Code\nwith open(\"demo.txt\", \"w\") as f:\n    f.write(\"Resource managed with 'with'\")\n\n\nWhy it Matters\nResource management is crucial to avoid memory leaks, file corruption, or dangling connections. The with statement makes code safer, cleaner, and more professional.\n\n\nTry It Yourself\n\nWrite a with open(\"data.txt\", \"r\") block that prints each line.\nUse with to copy one file into another.\nCreate a threading lock and use it with with in a simple program.\nWrite a custom class with __enter__ and __exit__ that logs when it starts and stops.\n\n\n\n\n89. Modules itertools & functools\nPython provides itertools and functools as standard libraries to work with iterators and functional programming tools. They let you process data efficiently and write more expressive code.\n\nDeep Dive\nitertools – Tools for Iteration\n\nInfinite Iterators\n\nimport itertools\n\ncounter = itertools.count(start=1, step=2)\nprint(next(counter))  # 1\nprint(next(counter))  # 3\n\nCycling and Repeating\n\ncolors = itertools.cycle([\"red\", \"green\", \"blue\"])\nprint(next(colors))  # red\nprint(next(colors))  # green\n\nrepeat_hello = itertools.repeat(\"hello\", 3)\nprint(list(repeat_hello))  # ['hello', 'hello', 'hello']\n\nCombinatorics\n\nfrom itertools import permutations, combinations\n\nprint(list(permutations([1, 2, 3], 2)))\n# [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]\n\nprint(list(combinations([1, 2, 3], 2)))\n# [(1, 2), (1, 3), (2, 3)]\n\nChaining Iterables\n\nfrom itertools import chain\nprint(list(chain(\"ABC\", \"123\")))  # ['A','B','C','1','2','3']\nfunctools – Tools for Functions\n\nreduce → apply a function cumulatively.\n\nfrom functools import reduce\n\nnums = [1, 2, 3, 4]\nproduct = reduce(lambda a, b: a * b, nums)\nprint(product)  # 24\n\nlru_cache → memoize function results.\n\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n &lt; 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(30))  # fast due to caching\n\npartial → fix some arguments of a function.\n\nfrom functools import partial\n\ndef power(base, exponent):\n    return base  exponent\n\nsquare = partial(power, exponent=2)\nprint(square(5))  # 25\nQuick Summary Table\n\n\n\n\n\n\n\n\n\nModule\nFunction\nExample\nPurpose\n\n\n\n\nitertools\ncount\ncount(1,2)\nInfinite counter\n\n\nitertools\ncycle\ncycle(['A','B'])\nRepeat sequence forever\n\n\nitertools\npermutations\npermutations([1,2,3],2)\nAll orderings\n\n\nitertools\ncombinations\ncombinations([1,2,3],2)\nAll unique pairs\n\n\nfunctools\nreduce\nreduce(lambda x,y: x+y, [1,2,3])\nCumulative reduction\n\n\nfunctools\nlru_cache\n@lru_cache\nCache results for speed\n\n\nfunctools\npartial\npartial(func, arg=value)\nPre-fill arguments\n\n\n\n\n\nTiny Code\nfrom itertools import accumulate\nprint(list(accumulate([1, 2, 3, 4])))  # [1, 3, 6, 10]\n\n\nWhy it Matters\nitertools and functools give you powerful building blocks for iteration and function manipulation. They make complex tasks simpler, faster, and more memory-efficient.\n\n\nTry It Yourself\n\nUse itertools.combinations to list all pairs from [1, 2, 3, 4].\nCreate an infinite counter with itertools.count() and print the first 5 values.\nUse functools.reduce to compute the sum of [10, 20, 30].\nDefine a cube function using functools.partial(power, exponent=3).\n\n\n\n\n90. Type Hints (typing Module)\nType hints let you specify the expected data types of variables, function arguments, and return values. They don’t change how the code runs, but they make it easier to read, maintain, and catch errors early with tools like mypy.\n\nDeep Dive\nBasic Function Hints\ndef greet(name: str) -&gt; str:\n    return \"Hello, \" + name\n\nname: str means name should be a string.\n-&gt; str means the function returns a string.\n\nVariable Hints\nage: int = 25\npi: float = 3.14159\nactive: bool = True\nUsing List, Dict, and Tuple\nfrom typing import List, Dict, Tuple\n\nnumbers: List[int] = [1, 2, 3]\nuser: Dict[str, int] = {\"Alice\": 25, \"Bob\": 30}\npoint: Tuple[int, int] = (10, 20)\nOptional Values\nfrom typing import Optional\n\ndef find_user(id: int) -&gt; Optional[str]:\n    if id == 1:\n        return \"Alice\"\n    return None\nUnion Types\nfrom typing import Union\n\ndef add(x: Union[int, float], y: Union[int, float]) -&gt; Union[int, float]:\n    return x + y\nType Aliases\nUserID = int\ndef get_user(id: UserID) -&gt; str:\n    return \"User\" + str(id)\nCallable (Functions as Arguments)\nfrom typing import Callable\n\ndef apply(func: Callable[[int, int], int], a: int, b: int) -&gt; int:\n    return func(a, b)\n\nprint(apply(lambda x, y: x + y, 2, 3))  # 5\nQuick Summary Table\n\n\n\nType Hint\nExample\nMeaning\n\n\n\n\nBasic\nx: int, def f()-&gt;str\nSimple types\n\n\nList, Dict\nList[int], Dict[str,int]\nCollections with types\n\n\nTuple\nTuple[int,str]\nFixed-size sequence\n\n\nOptional\nOptional[str]\nString or None\n\n\nUnion\nUnion[int,float]\nOne of several types\n\n\nCallable\nCallable[[int,int],int]\nFunction type\n\n\nAlias\nUserID = int\nCustom type name\n\n\n\n\n\nTiny Code\nfrom typing import List\n\ndef average(values: List[float]) -&gt; float:\n    return sum(values) / len(values)\n\nprint(average([1.0, 2.0, 3.0]))  # 2.0\n\n\nWhy it Matters\nType hints improve clarity and enable better error detection during development. They help teams understand code faster and catch mistakes before running the program.\n\n\nTry It Yourself\n\nAdd type hints to a function def square(x): return x*x.\nWrite a function join(names) that expects a List[str] and returns a str.\nUse Optional[int] for a function that may return None.\nCreate a function operate that accepts a Callable[[int,int],int] and applies it to two numbers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-10.-python-in-practices",
    "href": "index.html#chapter-10.-python-in-practices",
    "title": "The Little Book of Python",
    "section": "Chapter 10. Python in Practices",
    "text": "Chapter 10. Python in Practices\n\n91. REPL & Interactive Mode\nPython comes with an interactive environment called the REPL (Read–Eval–Print Loop). It lets you type Python commands one at a time and see results immediately, making it perfect for learning, testing, and quick experiments.\n\nDeep Dive\nOpen a terminal and type:\npython\nor sometimes:\npython3\nYou’ll see a prompt like:\n&gt;&gt;&gt;\nwhere you can type Python code directly.\nBasic Usage\n&gt;&gt;&gt; 2 + 3\n5\n&gt;&gt;&gt; \"hello\".upper()\n'HELLO'\nThe REPL evaluates each expression and prints the result instantly.\nMulti-line Input For blocks like loops or functions, use indentation:\n&gt;&gt;&gt; for i in range(3):\n...     print(i)\n...\n0\n1\n2\nExploring Objects You can quickly inspect functions and objects:\n&gt;&gt;&gt; help(str)\n&gt;&gt;&gt; dir(list)\nUsing the Underscore _ The REPL stores the last result in _:\n&gt;&gt;&gt; 5 * 5\n25\n&gt;&gt;&gt; _ + 10\n35\nExiting the REPL\n\nPress Ctrl+D (Linux/Mac) or Ctrl+Z + Enter (Windows).\nOr type exit() or quit().\n\nEnhanced REPLs\n\nIPython → advanced REPL with colors, auto-complete, and history.\nJupyter Notebook → browser-based interactive coding environment.\n\nQuick Summary Table\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nRun REPL\npython\nStart interactive mode\n\n\nExpression\n2 + 3 → 5\nImmediate evaluation\n\n\nMulti-line\nfor i in ...\nSupports blocks of code\n\n\nInspect object\ndir(obj), help(obj)\nExplore methods & docs\n\n\nLast result\n_\nUse last computed value\n\n\n\n\n\nTiny Code\n&gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 20\n&gt;&gt;&gt; x + y\n30\n&gt;&gt;&gt; _\n30\n&gt;&gt;&gt; _ * 2\n60\n\n\nWhy it Matters\nThe REPL makes Python beginner-friendly and powerful for professionals. It’s like a live scratchpad where you can test ideas, debug small snippets, or explore libraries interactively.\n\n\nTry It Yourself\n\nStart the Python REPL and calculate 7 * 8.\nUse help(int) to see details about integers.\nAssign a variable, then use _ to reuse its value.\nTry an enhanced REPL like ipython for auto-completion.\n\n\n\n\n92. Debugging (pdb)\nPython includes a built-in debugger called pdb. It allows you to pause execution, step through code line by line, inspect variables, and find bugs interactively.\n\nDeep Dive\nStarting the Debugger Insert this line where you want to pause:\nimport pdb; pdb.set_trace()\nWhen the program runs, it will stop there and open an interactive debugging session.\nCommon pdb Commands\n\n\n\nCommand\nMeaning\n\n\n\n\nn\nNext line (step over)\n\n\ns\nStep into a function\n\n\nc\nContinue until next breakpoint\n\n\nl\nList source code around current line\n\n\np var\nPrint the value of var\n\n\nq\nQuit the debugger\n\n\nb num\nSet a breakpoint at line number num\n\n\n\nExample Debugging Session\ndef divide(a, b):\n    result = a / b\n    return result\n\nx = 10\ny = 0\n\nimport pdb; pdb.set_trace()\nprint(divide(x, y))\nWhen run:\n(Pdb) p x\n10\n(Pdb) p y\n0\n(Pdb) n\nZeroDivisionError: division by zero\nRunning a Script with Debug Mode You can also run the debugger directly from the command line:\npython -m pdb myscript.py\nModern Alternatives\n\nipdb → improved pdb with colors and better interface.\ndebugpy → used in VS Code and IDEs for integrated debugging.\n\n\n\nTiny Code\ndef greet(name):\n    message = \"Hello \" + name\n    return message\n\nimport pdb; pdb.set_trace()\nprint(greet(\"Alice\"))\nInside pdb, type:\n(Pdb) p name\n(Pdb) n\n\n\nWhy it Matters\nDebugging with pdb helps you see exactly what your program is doing step by step. Instead of guessing where things go wrong, you can inspect state directly and fix issues faster.\n\n\nTry It Yourself\n\nWrite a function that divides two numbers and insert pdb.set_trace() before the division. Step through and print variables.\nRun a script with python -m pdb file.py and use n and s to move through code.\nTry setting a breakpoint with b and continuing with c.\nExperiment with inspecting variables using p var during debugging.\n\n\n\n\n93. Logging (logging Module)\nThe logging module in Python is used to record messages about what your program is doing. Unlike print(), logging is flexible, configurable, and suitable for real-world applications.\n\nDeep Dive\nBasic Logging\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogging.info(\"Program started\")\nlogging.warning(\"This is a warning\")\nlogging.error(\"An error occurred\")\nOutput:\nINFO:root:Program started\nWARNING:root:This is a warning\nERROR:root:An error occurred\nLog Levels Logging has different severity levels:\n\n\n\nLevel\nFunction\nMeaning\n\n\n\n\nDEBUG\nlogging.debug()\nDetailed information for devs\n\n\nINFO\nlogging.info()\nGeneral program information\n\n\nWARNING\nlogging.warning()\nSomething unexpected happened\n\n\nERROR\nlogging.error()\nA serious problem occurred\n\n\nCRITICAL\nlogging.critical()\nVery severe error\n\n\n\nCustom Formatting\nlogging.basicConfig(\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",\n    level=logging.DEBUG\n)\n\nlogging.debug(\"Debugging details\")\nExample output:\n2025-09-14 19:30:01,234 - DEBUG - Debugging details\nLogging to a File\nlogging.basicConfig(filename=\"app.log\", level=logging.INFO)\nlogging.info(\"This message goes into the log file\")\nSeparate Logger Instances\nlogger = logging.getLogger(\"myapp\")\nlogger.setLevel(logging.DEBUG)\n\nlogger.info(\"App is running\")\nWhy Logging Instead of Print?\n\nprint() always goes to stdout.\nlogging lets you choose where messages go: console, file, system log, etc.\nYou can control severity and disable logs without changing code.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nBasic log\nlogging.info(\"msg\")\nSimple logging\n\n\nLevels\nDEBUG, INFO, WARNING, etc.\nControl importance\n\n\nFormatting\n%(asctime)s - %(levelname)s...\nAdd timestamps, names\n\n\nTo file\nfilename=\"app.log\"\nPersist logs\n\n\nCustom logger\ngetLogger(\"name\")\nSeparate log sources\n\n\n\n\n\nTiny Code\nimport logging\n\nlogging.basicConfig(level=logging.WARNING)\nlogging.debug(\"Hidden\")\nlogging.warning(\"Visible warning\")\n\n\nWhy it Matters\nLogging is essential for debugging, monitoring, and auditing applications. It helps you understand what your code does in production without spamming users with print statements.\n\n\nTry It Yourself\n\nWrite a script that logs an INFO message when it starts and an ERROR when something goes wrong.\nChange log formatting to include the date and time.\nConfigure logging to write output to a file instead of the console.\nCreate two different loggers: one for db and one for api, with different log levels.\n\n\n\n\n94. Unit Testing (unittest)\nPython’s unittest module provides a framework for writing and running automated tests. It helps you verify that your code works as expected and prevents future changes from breaking existing functionality.\n\nDeep Dive\nBasic Test Case\nimport unittest\n\ndef add(a, b):\n    return a + b\n\nclass TestMath(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\nif __name__ == \"__main__\":\n    unittest.main()\nRunning the script:\n.\n----------------------------------------------------------------------\nRan 1 test in 0.000s\n\nOK\nCommon Assertions\n\n\n\n\n\n\n\n\nMethod\nUsage Example\nPurpose\n\n\n\n\nassertEqual(a, b)\nassertEqual(x, 10)\nCheck equality\n\n\nassertNotEqual(a, b)\nassertNotEqual(x, 5)\nCheck inequality\n\n\nassertTrue(x)\nassertTrue(flag)\nCheck condition is True\n\n\nassertFalse(x)\nassertFalse(flag)\nCheck condition is False\n\n\nassertIn(a, b)\nassertIn(3, [1,2,3])\nCheck membership\n\n\nassertRaises(error)\nwith self.assertRaises(ValueError):\nCheck exception raised\n\n\n\nTesting Exceptions\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\nclass TestDivide(unittest.TestCase):\n    def test_zero_division(self):\n        with self.assertRaises(ValueError):\n            divide(5, 0)\nGrouping Multiple Tests\nclass TestStrings(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\"hello\".upper(), \"HELLO\")\n    \n    def test_isupper(self):\n        self.assertTrue(\"HELLO\".isupper())\n        self.assertFalse(\"Hello\".isupper())\nRunning Tests\n\nRun directly:\n\npython test_file.py\n\nOr use:\n\npython -m unittest discover\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nTest class\nclass TestX(unittest.TestCase)\nGroup related tests\n\n\nAssertion methods\nassertEqual, assertTrue\nValidate expected behavior\n\n\nException testing\nassertRaises\nCheck error handling\n\n\nDiscover tests\nunittest discover\nAuto-run all tests\n\n\n\n\n\nTiny Code\nimport unittest\n\nclass TestBasics(unittest.TestCase):\n    def test_sum(self):\n        self.assertEqual(sum([1,2,3]), 6)\n\nif __name__ == \"__main__\":\n    unittest.main()\n\n\nWhy it Matters\nUnit tests catch bugs early, make code safer to change, and provide confidence that your program works correctly. They are a cornerstone of professional software development.\n\n\nTry It Yourself\n\nWrite a function multiply(a, b) and a test to check multiply(2, 5) == 10.\nAdd a test that verifies dividing by zero raises a ValueError.\nTest that \"python\".upper() returns \"PYTHON\".\nRun your tests with python -m unittest.\n\n\n\n\n95. Virtual Environments Best Practice\nA virtual environment is an isolated Python environment that allows you to install packages without affecting the system-wide Python installation. It’s the best practice for managing dependencies in projects.\n\nDeep Dive\nWhy Use Virtual Environments?\n\nAvoid conflicts between project dependencies.\nKeep each project self-contained.\nEasier to reproduce the same setup on another machine.\n\nCreating a Virtual Environment\npython -m venv venv\nThis creates a folder venv/ that holds the environment.\nActivating the Virtual Environment\n\nLinux / macOS:\n\nsource venv/bin/activate\n\nWindows (cmd):\n\nvenv\\Scripts\\activate\nAfter activation, your shell prompt changes, e.g.:\n(venv) $\nInstalling Packages Inside the environment, install packages as usual:\npip install requests\nOnly this environment will have it.\nFreezing Requirements Save dependencies to a file:\npip freeze &gt; requirements.txt\nReinstall them elsewhere:\npip install -r requirements.txt\nDeactivating the Environment\ndeactivate\nBest Practices\n\nAlways create a virtual environment for new projects.\nUse requirements.txt for reproducibility.\nDon’t commit the venv/ folder to version control.\nConsider tools like pipenv or poetry for advanced dependency management.\n\nQuick Summary Table\n\n\n\nCommand\nPurpose\n\n\n\n\npython -m venv venv\nCreate environment\n\n\nsource venv/bin/activate\nActivate (Linux/macOS)\n\n\nvenv\\Scripts\\activate\nActivate (Windows)\n\n\npip install package\nInstall inside environment\n\n\npip freeze &gt; requirements.txt\nSave dependencies\n\n\ndeactivate\nExit environment\n\n\n\n\n\nTiny Code\npython -m venv venv\nsource venv/bin/activate\npip install flask\npip freeze &gt; requirements.txt\n\n\nWhy it Matters\nVirtual environments prevent dependency chaos. They ensure that one project’s libraries don’t break another’s, making projects portable and maintainable.\n\n\nTry It Yourself\n\nCreate a virtual environment called myenv.\nActivate it and install the package requests.\nRun pip freeze to confirm the installed package.\nDeactivate the environment, then reactivate it.\n\n\n\n\n96. Writing a Simple Script\nPython scripts are just plain text files with .py extension. They can contain functions, logic, and be executed directly from the command line.\n\nDeep Dive\nHello World Script Create a file hello.py:\nprint(\"Hello, Python script!\")\nRun it:\npython hello.py\nUsing if __name__ == \"__main__\": This ensures some code only runs when the file is executed directly, not when imported as a module.\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    print(greet(\"Alice\"))\nRunning python hello.py prints:\nHello, Alice!\nBut if you import it in another file:\nimport hello\nprint(hello.greet(\"Bob\"))\nIt won’t run the main block automatically.\nAccepting Command-Line Arguments Use the sys module:\nimport sys\n\nname = sys.argv[1] if len(sys.argv) &gt; 1 else \"World\"\nprint(f\"Hello, {name}!\")\nRun it:\npython script.py Alice\n# Output: Hello, Alice!\nMaking the Script Executable (Linux/macOS) At the top of the file:\n#!/usr/bin/env python3\nThen give permission:\nchmod +x hello.py\n./hello.py\nQuick Summary Table\n\n\n\n\n\n\n\n\nConcept\nExample\nPurpose\n\n\n\n\nSimple script\nprint(\"Hello\")\nFirst step in scripting\n\n\nMain guard\nif __name__ == \"__main__\":\nControl script vs import\n\n\nCommand-line arguments\nsys.argv\nPass input via terminal\n\n\nExecutable script (Unix)\n#!/usr/bin/env python3 + chmod +x\nRun without python prefix\n\n\n\n\n\nTiny Code\nimport sys\n\ndef square(n: int) -&gt; int:\n    return n * n\n\nif __name__ == \"__main__\":\n    num = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 5\n    print(f\"Square of {num} is {square(num)}\")\n\n\nWhy it Matters\nScripts turn Python into a tool for automation. With just a few lines, you can create utilities, batch jobs, or prototypes that are reusable and shareable.\n\n\nTry It Yourself\n\nWrite a script greet.py that prints \"Hello, Python learner!\".\nAdd a function double(x) and use if __name__ == \"__main__\": to call it.\nModify the script to accept a number from the command line.\nMake the script executable on Linux/macOS with a shebang line.\n\n\n\n\n97. CLI Arguments (argparse)\nPython’s argparse module makes it easy to build user-friendly command-line interfaces (CLI). Instead of manually reading sys.argv, you can define arguments, defaults, help text, and parsing rules automatically.\n\nDeep Dive\nBasic Example\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"name\")\nargs = parser.parse_args()\n\nprint(f\"Hello, {args.name}!\")\nRun:\npython script.py Alice\n# Output: Hello, Alice!\nOptional Arguments\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--age\", type=int, default=18, help=\"Your age\")\nargs = parser.parse_args()\n\nprint(f\"Age: {args.age}\")\nRun:\npython script.py --age 25\n# Output: Age: 25\nMultiple Arguments\nparser = argparse.ArgumentParser()\nparser.add_argument(\"x\", type=int)\nparser.add_argument(\"y\", type=int)\nargs = parser.parse_args()\n\nprint(args.x + args.y)\nRun:\npython script.py 5 7\n# Output: 12\nFlags (True/False)\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--verbose\", action=\"store_true\")\nargs = parser.parse_args()\n\nif args.verbose:\n    print(\"Verbose mode on\")\nRun:\npython script.py --verbose\n# Output: Verbose mode on\nQuick Summary Table\n\n\n\n\n\n\n\n\nFeature\nExample\nPurpose\n\n\n\n\nPositional arg\nparser.add_argument(\"name\")\nRequired input\n\n\nOptional arg\n--age 25\nExtra info with defaults\n\n\nType conversion\ntype=int\nEnforce types\n\n\nFlags\naction=\"store_true\"\nOn/off switches\n\n\nHelp text\nhelp=\"description\"\nUser guidance\n\n\n\n\n\nTiny Code\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Square a number\")\nparser.add_argument(\"num\", type=int, help=\"The number to square\")\nargs = parser.parse_args()\n\nprint(args.num  2)\nRun:\npython script.py 6\n# Output: 36\n\n\nWhy it Matters\nWith argparse, your Python scripts behave like real command-line tools. They’re more professional, self-documenting, and easier to use.\n\n\nTry It Yourself\n\nWrite a script that accepts a --name argument and prints a greeting.\nAdd a --times argument that repeats the greeting multiple times.\nCreate a flag --shout that prints the greeting in uppercase.\nRun your script with -h to see the auto-generated help message.\n\n\n\n\n98. Working with APIs (requests)\nAPIs let programs talk to each other over the web. Python’s requests library makes sending HTTP requests simple and readable. You can use it to fetch data, send data, or interact with web services.\n\nDeep Dive\nMaking a GET Request\nimport requests\n\nresponse = requests.get(\"https://jsonplaceholder.typicode.com/posts/1\")\nprint(response.status_code)   # 200 means success\nprint(response.json())        # Parse response as JSON\nQuery Parameters\nurl = \"https://jsonplaceholder.typicode.com/posts\"\nparams = {\"userId\": 1}\nresponse = requests.get(url, params=params)\nprint(response.json())   # All posts from userId=1\nPOST Request (Send Data)\ndata = {\"title\": \"foo\", \"body\": \"bar\", \"userId\": 1}\nresponse = requests.post(\"https://jsonplaceholder.typicode.com/posts\", json=data)\nprint(response.json())\nHandling Errors\nresponse = requests.get(\"https://jsonplaceholder.typicode.com/invalid\")\nif response.status_code != 200:\n    print(\"Error:\", response.status_code)\nHeaders and Authentication\nheaders = {\"Authorization\": \"Bearer mytoken\"}\nresponse = requests.get(\"https://api.example.com/data\", headers=headers)\nQuick Summary Table\n\n\n\nMethod\nExample\nPurpose\n\n\n\n\nGET\nrequests.get(url)\nRetrieve data\n\n\nPOST\nrequests.post(url, json=data)\nSend data\n\n\nPUT\nrequests.put(url, json=data)\nUpdate resource\n\n\nDELETE\nrequests.delete(url)\nRemove resource\n\n\nparams arg\nget(url, params={})\nAdd query string\n\n\nheaders arg\nget(url, headers={})\nSet custom headers\n\n\n\n\n\nTiny Code\nimport requests\n\nr = requests.get(\"https://api.github.com\")\nprint(\"Status:\", r.status_code)\nprint(\"Headers:\", r.headers[\"content-type\"])\n\n\nWhy it Matters\nAPIs are everywhere—from weather apps to payment systems. Knowing how to interact with them lets you integrate external services into your projects.\n\n\nTry It Yourself\n\nUse requests.get to fetch JSON from https://jsonplaceholder.typicode.com/todos/1.\nExtract and print the \"title\" field from the response.\nSend a POST request with your own JSON data.\nExperiment with adding query parameters like userId=2 to filter results.\n\n\n\n\n99. Basics of Web Scraping (BeautifulSoup)\nWeb scraping means extracting information from websites automatically. In Python, this is commonly done using requests to fetch the page and BeautifulSoup (bs4) to parse the HTML.\n\nDeep Dive\nInstalling BeautifulSoup\npip install requests beautifulsoup4\nFetching a Webpage\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = \"https://example.com\"\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.text, \"html.parser\")\nExtracting Data\n\nGet the page title:\n\nprint(soup.title.string)\n\nFind the first paragraph:\n\nprint(soup.p.text)\n\nFind all links:\n\nfor link in soup.find_all(\"a\"):\n    print(link.get(\"href\"))\nSearching by CSS Class\nsoup.find_all(\"div\", class_=\"article\")\nPractical Example Scraping article headlines:\nurl = \"https://news.ycombinator.com\"\nres = requests.get(url)\nsoup = BeautifulSoup(res.text, \"html.parser\")\n\ntitles = soup.find_all(\"a\", class_=\"storylink\")\nfor t in titles[:5]:\n    print(t.text)\nRespect Robots.txt and Rules\n\nAlways check if scraping is allowed (/robots.txt).\nDon’t overload websites with too many requests.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nMethod\nExample\nPurpose\n\n\n\n\nsoup.title.string\nGet title\nPage metadata\n\n\nsoup.p.text\nGet first &lt;p&gt; text\nParagraphs\n\n\nsoup.find_all(\"a\")\nExtract all links\nNavigation, references\n\n\nsoup.find_all(\"div\", class_=\"x\")\nFind elements by class\nStructured data extraction\n\n\n\n\n\nTiny Code\nimport requests\nfrom bs4 import BeautifulSoup\n\nres = requests.get(\"https://example.com\")\nsoup = BeautifulSoup(res.text, \"html.parser\")\n\nprint(\"Title:\", soup.title.string)\nprint(\"First paragraph:\", soup.p.text)\n\n\nWhy it Matters\nWeb scraping lets you automate data collection from websites—useful for research, market analysis, or building datasets when APIs aren’t available.\n\n\nTry It Yourself\n\nScrape the title of https://example.com.\nExtract and print all &lt;h1&gt; headers from the page.\nCollect all links (href) on the page.\nTry scraping a news site (like Hacker News) and print the first 10 headlines.\n\n\n\n\n100. Next Steps: Where to Go from Here\nNow that you’ve mastered the Python flashcards, you have the foundation to build almost anything. The next step is to choose a direction and deepen your skills in areas that interest you most.\n\nDeep Dive\n\nData Science & Machine Learning\n\n\nLibraries: numpy, pandas, matplotlib, scikit-learn\nLearn to analyze datasets, build models, and visualize results.\nProgress into deep learning with tensorflow or pytorch.\n\n\nWeb Development\n\n\nFrameworks: flask, django, fastapi\nLearn to build APIs, web apps, and services.\nExplore front-end integration with JavaScript frameworks.\n\n\nAutomation & Scripting\n\n\nUse Python to automate repetitive tasks (file handling, Excel reports, web scraping).\nExplore selenium for browser automation.\n\n\nSystems & DevOps\n\n\nLearn about Python in DevOps: fabric, ansible, or working with Docker/Kubernetes APIs.\nUse Python for cloud services (AWS, GCP, Azure SDKs).\n\n\nComputer Science Foundations\n\n\nStudy algorithms and data structures with Python.\nExplore competitive programming and problem-solving platforms (LeetCode, HackerRank).\n\nLearning Pathways\n\nBooks: Fluent Python, Automate the Boring Stuff with Python, Python Crash Course.\nOnline platforms: Coursera, edX, freeCodeCamp.\nOpen-source projects: contribute on GitHub to gain real experience.\n\nQuick Summary Table\n\n\n\n\n\n\n\n\nDirection\nLibraries / Tools\nExample Goal\n\n\n\n\nData Science\nnumpy, pandas, scikit\nBuild a recommendation system\n\n\nWeb Development\nflask, django\nCreate a blog or API\n\n\nAutomation\nrequests, selenium\nAutomate a daily reporting workflow\n\n\nDevOps & Cloud\nboto3, ansible\nDeploy an app to AWS automatically\n\n\nCS Foundations\nheapq, collections\nImplement algorithms in Python\n\n\n\n\n\nTiny Code (Automation Example)\nimport requests\n\ndef get_weather(city):\n    url = f\"https://wttr.in/{city}?format=3\"\n    res = requests.get(url)\n    return res.text\n\nprint(get_weather(\"London\"))\n\n\nWhy it Matters\nPython is not just a language—it’s a gateway. Whether you’re interested in AI, finance, web apps, or automating your own life, Python is a tool that grows with you.\n\n\nTry It Yourself\n\nChoose one domain (web, data, AI, automation).\nInstall the relevant libraries (pip install flask pandas torch, etc.).\nBuild a small project (e.g., a to-do app, data analysis notebook, or web scraper).\nShare your project on GitHub to start building a portfolio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Little Book of Python</span>"
    ]
  }
]